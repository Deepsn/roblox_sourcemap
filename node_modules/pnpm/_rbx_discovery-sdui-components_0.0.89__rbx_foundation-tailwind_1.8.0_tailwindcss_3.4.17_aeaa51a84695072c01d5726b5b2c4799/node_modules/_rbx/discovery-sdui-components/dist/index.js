import React, { useState, useCallback, useRef, useEffect, useMemo } from 'react';
import { makeStyles, Button } from '@rbx/ui';
import { mergeRefs } from 'react-merge-refs';
import classNames from 'classnames';
import ResizeObserverPolyfill from 'resize-observer-polyfill';
import bezier from 'bezier-easing';
import throttle from 'lodash.throttle';
import domPurify from 'dompurify';
import Color from 'color';
import debounce from 'lodash.debounce';

const AssociatedItemsRow = ({ items, renderItem }) => (React.createElement("div", { className: 'flex-nowrap gap-small flex' }, items.map((item, itemIndex) => (React.createElement(React.Fragment
// eslint-disable-next-line react/no-array-index-key
, { 
    // eslint-disable-next-line react/no-array-index-key
    key: itemIndex }, renderItem(item, itemIndex))))));

// Data attribute is used to increase specificity, which is necessary to
// override the default text styles in web-frontend (like .builder-font div)
const defaultTextDataAttributeConfig = {
    key: 'data-sdui-text',
    value: 'true'
};
const getTextDataAttribute = (dataAttributeConfig) => {
    return {
        [`${dataAttributeConfig.key}`]: dataAttributeConfig.value
    };
};
const getTextStyles = (dataAttributeConfig, textColor, fontStyle) => {
    return {
        [`&[${dataAttributeConfig.key}='${dataAttributeConfig.value}']`]: {
            color: textColor,
            ...(fontStyle && {
                font: fontStyle.Font,
                letterSpacing: fontStyle.LetterSpacing,
                fontFamily: fontStyle.FontFamily,
                fontWeight: fontStyle.FontWeight,
                fontSize: fontStyle.FontSize,
                lineHeight: fontStyle.LineHeight
            })
        }
    };
};

/**
 * AttributionTextContent component displays a title and subtitle.
 *
 * @component
 * @param {string} title - The title text to be displayed.
 * @param {React.ReactNode} titleComponent - Optional component to replace the title. Overrides title, textColor, and titleFontStyle.
 * @param {string} subtitle - The subtitle text to be displayed.
 * @param {string} textColor - The color of the text to be displayed.
 * @param {string} textGap - The gap between the title and subtitle.
 * @param {TTypographyToken} titleFontStyle - The font style of the title.
 * @param {TTypographyToken} subtitleFontStyle - The font style of the subtitle.
 * @param {number} subtitleMaxLines - The maximum number of lines the subtitle can have.
 * @param {number} titleMaxLines - The maximum number of lines the title can have.
 *
 * @returns {JSX.Element} The rendered attribution text content component.
 *
 * @example
 * <AttributionTextContent
 *   title="Sample Title"
 *   subtitle="Sample Subtitle"
 *   textColor="white"
 *   textGap="8px"
 *   titleFontStyle={{
 *     Font: '700 14/1.2 "Builder Sans"',
 *     LetterSpacing: -0.01,
 *     FontFamily: '"Builder Sans"',
 *     FontWeight: '700',
 *     FontSize: 14,
 *     LineHeight: 1.2
 *   }}
 *   subtitleFontStyle={{
 *     Font: '400 14/1.4 "Builder Sans"',
 *     LetterSpacing: 0,
 *     FontFamily: '"Builder Sans"',
 *     FontWeight: '400',
 *     FontSize: 14,
 *     LineHeight: 1.4
 *   }}
 *   subtitleMaxLines={1}
 *   titleMaxLines={1}
 * />
 */
const useStyle$6 = makeStyles({ name: 'AttributionTextContent' })((_theme, { subtitleMaxLines, subtitleFontStyle, textColor, textGap, titleFontStyle, titleMaxLines }) => {
    return {
        attributionTextContentContainer: {
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'start',
            gap: `${textGap}px`,
            maxWidth: '100%'
        },
        attributionSubtitle: {
            fontSize: '14px',
            fontStyle: 'normal',
            fontWeight: 400,
            lineHeight: '140%',
            overflow: 'hidden',
            display: '-webkit-box',
            WebkitLineClamp: subtitleMaxLines,
            WebkitBoxOrient: 'vertical',
            ...getTextStyles(defaultTextDataAttributeConfig, textColor, subtitleFontStyle)
        },
        attributionTitle: {
            overflow: 'hidden',
            display: '-webkit-box',
            WebkitLineClamp: titleMaxLines,
            WebkitBoxOrient: 'vertical',
            ...getTextStyles(defaultTextDataAttributeConfig, textColor, titleFontStyle)
        }
    };
});
const AttributionTextContent = ({ title, titleComponent, subtitle, textColor, titleFontStyle, subtitleFontStyle, subtitleMaxLines = 1, textGap = 0, titleMaxLines = 1 }) => {
    const { classes } = useStyle$6({
        subtitleMaxLines,
        subtitleFontStyle,
        textColor,
        textGap,
        titleMaxLines,
        titleFontStyle
    });
    return (React.createElement("div", { className: classes.attributionTextContentContainer, "data-testid": 'attribution-text-content-container' },
        titleComponent || (React.createElement("span", { className: classes.attributionTitle, ...getTextDataAttribute(defaultTextDataAttributeConfig) }, title)),
        subtitle && (React.createElement("span", { className: classes.attributionSubtitle, ...getTextDataAttribute(defaultTextDataAttributeConfig) }, subtitle))));
};

const useStyle$5 = makeStyles()((_theme, { height }) => ({
    attributionRowContainer: {
        display: 'flex',
        position: 'relative',
        flexDirection: 'row',
        alignItems: 'center',
        width: '100%',
        height: height ? `${height}px` : 'auto'
    },
    attributionRowThumbnailContainer: {
        height: '100%',
        aspectRatio: `1`,
        display: 'flex',
        flexDirection: 'column',
        borderRadius: '8px',
        overflow: 'hidden',
        marginRight: '12px'
    },
    attributionRowButtonContainer: {
        marginLeft: 'auto'
    }
}));
/**
 * AttributionRow component displays a row with a thumbnail, title, subtitle, and a button.
 *
 * @component
 * @param {string} title - The title text to be displayed.
 * @param {React.ReactNode} titleComponent - Optional component to replace the title. Overrides title, textColor, and titleFontStyle.
 * @param {TTypographyToken} titleFontStyle - The font style of the title.
 * @param {string} subtitle - The subtitle text to be displayed.
 * @param {TTypographyToken} subtitleFontStyle - The font style of the subtitle.
 * @param {number} subtitleMaxLines - The maximum number of lines the subtitle can have.
 * @param {number} titleSubtitleGap - The gap between the title and subtitle.
 * @param {string} textColor - The color of the text to be displayed.
 * @param {number} height - The height of the attribution row.
 * @param {React.ReactNode} imageComponent - The component to be displayed on the left
 * @param {React.ReactNode} rightButtonContent - The component to be displayed as the button on the right.
 * @param {number} titleMaxLines - The maximum number of lines the title can have.
 * @returns {JSX.Element} The rendered attribution row component.
 *
 * @example
 * <AttributionRow
 *   title="Sample Title"
 *   subtitle="Sample Subtitle"
 *   textColor="white"
 *   height={40}
 *   image={<img src="thumbnail.jpg" alt="thumbnail" />}
 *   rightButtonContent={<button>Join</button>}
 * />
 */
const AttributionRow = ({ title, titleComponent, subtitle, textColor, height, imageComponent, rightButtonContent, titleFontStyle, subtitleFontStyle, subtitleMaxLines, titleSubtitleGap, titleMaxLines }) => {
    const { classes: { attributionRowContainer, attributionRowThumbnailContainer, attributionRowButtonContainer } } = useStyle$5({ height });
    return (React.createElement("div", { className: attributionRowContainer },
        imageComponent && React.createElement("div", { className: attributionRowThumbnailContainer }, imageComponent),
        React.createElement(AttributionTextContent, { title: title, titleComponent: titleComponent, subtitle: subtitle, textColor: textColor, titleFontStyle: titleFontStyle, subtitleFontStyle: subtitleFontStyle, subtitleMaxLines: subtitleMaxLines, textGap: titleSubtitleGap, titleMaxLines: titleMaxLines }),
        rightButtonContent && (React.createElement("div", { className: attributionRowButtonContainer }, rightButtonContent))));
};

const keyBoardEventCode = {
    enter: 'Enter',
    escape: 'Escape'
};
const textFormatDelimiters = {
    lineBreak: '{lineBreak}',
    linkStart: '{linkStart}',
    linkEnd: '{linkEnd}'
};

/**
 * Renders a single scroll arrow component, supporting clicks and keyboard enter selection.
 */
const ScrollArrow = ({ scrollArrowClassName, scrollIconClassName, handleClick }) => {
    return (
    // eslint-disable-next-line jsx-a11y/control-has-associated-label
    React.createElement("div", { "data-testid": 'carousel-scroll-arrow', className: scrollArrowClassName, onClick: handleClick, onKeyDown: e => {
            if (e.code === keyBoardEventCode.enter) {
                e.stopPropagation();
                e.preventDefault();
                handleClick();
            }
        }, role: 'button', tabIndex: 0 },
        React.createElement("span", { className: scrollIconClassName, "data-testid": 'carousel-scroll-arrow-icon' })));
};

/**
 * Renders the left and right scroll arrows on top of a scrollable carousel
 */
const ScrollArrows = ({ isScrollBackDisabled, isScrollForwardDisabled, onScrollBack, onScrollForward, scrollBackArrowClassName, scrollForwardArrowClassName }) => {
    return (React.createElement(React.Fragment, null,
        !isScrollBackDisabled && (React.createElement(ScrollArrow, { scrollArrowClassName: scrollBackArrowClassName, scrollIconClassName: 'icon-chevron-heavy-left', handleClick: onScrollBack })),
        !isScrollForwardDisabled && (React.createElement(ScrollArrow, { scrollArrowClassName: scrollForwardArrowClassName, scrollIconClassName: 'icon-chevron-heavy-right', handleClick: onScrollForward }))));
};

const ResizeObserverOrPolyfill = typeof window !== 'undefined' && window.ResizeObserver
    ? window.ResizeObserver
    : ResizeObserverPolyfill;
const useElementWidthResizeObserver = () => {
    const [elementWidth, setElementWidth] = useState(undefined);
    const updateElementWidth = useCallback((element) => {
        const width = element?.getBoundingClientRect()?.width;
        if (width !== undefined) {
            setElementWidth(width);
        }
    }, []);
    const handleResize = useCallback((entries) => {
        if (entries && entries[0] && entries[0].target) {
            updateElementWidth(entries[0].target);
        }
    }, [updateElementWidth]);
    const observerRef = useRef(new ResizeObserverOrPolyfill(handleResize));
    const elementRef = useCallback((node) => {
        if (node && observerRef?.current) {
            updateElementWidth(node);
            observerRef.current.disconnect();
            observerRef.current.observe(node);
        }
    }, [updateElementWidth]);
    useEffect(() => {
        const observer = observerRef.current;
        return () => {
            if (observer) {
                observer.disconnect();
            }
        };
    }, []);
    return [elementRef, elementWidth];
};

/**
 * Custom hook for horizontal scrolling of a carousel
 *
 * Based on a configuration of numColumns, columnGap, itemWidth, and carouselWidth,
 * the hook provides callbacks for scrolling forwards and backwards.
 */
const useCarouselHorizontalScroll = (shouldUseHorizontalScroll, itemWidth, carouselWidth, numColumns, columnGap, totalNumberOfItems, thresholdFromEnd, onReachedThresholdFromEnd, reportHorizontalScrollTelemetry) => {
    const currentScrollIndexRef = useRef(0);
    const carouselScrollRef = useRef(null);
    const [isScrollBackDisabled, setIsScrollBackDisabled] = useState(false);
    const [isScrollForwardDisabled, setIsScrollForwardDisabled] = useState(false);
    const [isScrolling, setIsScrolling] = useState(false);
    const hasReachedThresholdRef = useRef(false);
    // Update the current scroll index within the bounds of the carousel
    const updateScrollIndex = useCallback((newIndex) => {
        if (newIndex < 0) {
            currentScrollIndexRef.current = 0;
        }
        else if (newIndex > totalNumberOfItems - numColumns) {
            currentScrollIndexRef.current = totalNumberOfItems - numColumns;
        }
        else {
            currentScrollIndexRef.current = newIndex;
        }
        return currentScrollIndexRef.current;
    }, [totalNumberOfItems, numColumns]);
    const checkShouldCallThresholdCallback = useCallback((newScrollLeft) => {
        if (!shouldUseHorizontalScroll || !onReachedThresholdFromEnd) {
            return;
        }
        if (carouselScrollRef.current && carouselWidth) {
            // Default threshold is 3x the carousel width, or the passed value if larger
            const threshold = Math.max(thresholdFromEnd ?? 0, 3 * carouselWidth);
            if (newScrollLeft + carouselWidth >= carouselScrollRef.current.scrollWidth - threshold) {
                if (!hasReachedThresholdRef.current) {
                    onReachedThresholdFromEnd();
                    hasReachedThresholdRef.current = true;
                }
            }
            else {
                hasReachedThresholdRef.current = false;
            }
        }
    }, [
        onReachedThresholdFromEnd,
        carouselScrollRef,
        carouselWidth,
        thresholdFromEnd,
        shouldUseHorizontalScroll
    ]);
    const snapToItem = useCallback((newIndex, isUserInitiated) => {
        if (carouselScrollRef.current) {
            const currentScrollValue = carouselScrollRef.current.scrollLeft;
            const newScrollValue = newIndex * (itemWidth + (columnGap ?? 0));
            carouselScrollRef.current.scrollLeft = newScrollValue;
            checkShouldCallThresholdCallback(newScrollValue);
            if (newIndex <= 0) {
                setIsScrollBackDisabled(true);
            }
            else {
                setIsScrollBackDisabled(false);
            }
            if (newIndex >= totalNumberOfItems - numColumns) {
                setIsScrollForwardDisabled(true);
            }
            else {
                setIsScrollForwardDisabled(false);
            }
            if (reportHorizontalScrollTelemetry && isUserInitiated) {
                reportHorizontalScrollTelemetry(newScrollValue - currentScrollValue, // scrollDistance
                currentScrollValue, // startingPosition
                carouselWidth ?? -1 // scrollAreaSize
                );
            }
        }
    }, [
        itemWidth,
        columnGap,
        checkShouldCallThresholdCallback,
        totalNumberOfItems,
        numColumns,
        carouselWidth,
        reportHorizontalScrollTelemetry
    ]);
    // On item resize, snap back to the current item index
    useEffect(() => {
        if (shouldUseHorizontalScroll) {
            snapToItem(currentScrollIndexRef.current, false);
        }
    }, [snapToItem, shouldUseHorizontalScroll]);
    const onScrollToNext = useCallback(() => {
        const newScrollIndex = updateScrollIndex(currentScrollIndexRef.current + numColumns);
        snapToItem(newScrollIndex, true);
    }, [updateScrollIndex, snapToItem, numColumns]);
    const onScrollToPrev = useCallback(() => {
        const newScrollIndex = updateScrollIndex(currentScrollIndexRef.current - numColumns);
        snapToItem(newScrollIndex, true);
    }, [updateScrollIndex, snapToItem, numColumns]);
    const onScrollHandlerThrottled = useCallback((onScrollHandler) => {
        if (!isScrolling) {
            setIsScrolling(true);
            onScrollHandler();
            // Briefly disable scrolling to prevent multiple repeated calls
            setTimeout(() => {
                setIsScrolling(false);
            }, 500);
        }
    }, [isScrolling]);
    const handleScrollBackClick = useCallback(() => {
        onScrollHandlerThrottled(onScrollToPrev);
    }, [onScrollToPrev, onScrollHandlerThrottled]);
    const handleScrollForwardClick = useCallback(() => {
        onScrollHandlerThrottled(onScrollToNext);
    }, [onScrollToNext, onScrollHandlerThrottled]);
    const getIsTileVisible = useCallback((index) => {
        return (index >= currentScrollIndexRef.current && index < currentScrollIndexRef.current + numColumns);
    }, [currentScrollIndexRef, numColumns]);
    return {
        carouselScrollRef,
        isScrollBackDisabled: isScrollBackDisabled || isScrolling,
        isScrollForwardDisabled: isScrollForwardDisabled || isScrolling,
        handleScrollBackClick,
        handleScrollForwardClick,
        getIsTileVisible
    };
};

var CollectionItemSize;
(function (CollectionItemSize) {
    CollectionItemSize["XSmall"] = "XSmall";
    CollectionItemSize["Small"] = "Small";
    CollectionItemSize["Medium"] = "Medium";
    CollectionItemSize["Large"] = "Large";
    CollectionItemSize["XLarge"] = "XLarge";
})(CollectionItemSize || (CollectionItemSize = {}));
const collectionCarouselLayoutConfig = {
    [CollectionItemSize.XSmall]: {
        minItemWidth: 80,
        minItemCount: 3,
        maxItemCount: 20,
        fractionalItemAmount: 0.15
    },
    [CollectionItemSize.Small]: {
        minItemWidth: 150,
        minItemCount: 3,
        maxItemCount: 12,
        fractionalItemAmount: 0.15
    },
    [CollectionItemSize.Medium]: {
        minItemWidth: 233,
        minItemCount: 2,
        maxItemCount: 6,
        fractionalItemAmount: 0.15
    },
    [CollectionItemSize.Large]: {
        minItemWidth: 300,
        minItemCount: 1,
        maxItemCount: 4,
        fractionalItemAmount: 0.3
    },
    [CollectionItemSize.XLarge]: {
        minItemWidth: 300,
        minItemCount: 1,
        maxItemCount: 1,
        fractionalItemAmount: 0.1
    }
};

const useCollectionLayoutParams = (collectionItemSize, containerWidth, layoutOverrides) => {
    const { minItemWidth, minItemCount, maxItemCount, fractionalItemAmount } = collectionCarouselLayoutConfig[collectionItemSize];
    const columnGap = useMemo(() => {
        if (layoutOverrides?.columnGap) {
            return layoutOverrides.columnGap;
        }
        if (!containerWidth) {
            return 18;
        }
        if (containerWidth < 1024) {
            return 12;
        }
        if (containerWidth < 1280) {
            return 18;
        }
        return 24;
    }, [layoutOverrides?.columnGap, containerWidth]);
    const sideMargin = layoutOverrides?.sideMargin ?? 0;
    const numColumns = useMemo(() => {
        if (containerWidth) {
            const availableSpace = containerWidth - sideMargin * 2;
            const desiredColumns = Math.floor((availableSpace + columnGap) / (minItemWidth + columnGap));
            return Math.min(Math.max(minItemCount, desiredColumns), maxItemCount);
        }
        return minItemCount;
    }, [containerWidth, minItemCount, maxItemCount, minItemWidth, columnGap, sideMargin]);
    const derivedNumColumns = layoutOverrides?.numColumns ?? numColumns;
    const derivedFractionalItemAmount = layoutOverrides?.fractionalItemAmount ?? fractionalItemAmount;
    return {
        numColumns: derivedNumColumns,
        fractionalItemAmount: derivedFractionalItemAmount,
        columnGap,
        sideMargin
    };
};

const useStyles$h = makeStyles()((_theme, { itemWidth, columnGap, sideMargin, gapBetweenHeaderAndItems, scrollArrowBackgroundColor, scrollArrowBoxShadowColor, scrollArrowBaseClassName, scrollArrowPrevClassName, scrollArrowNextClassName }) => ({
    collectionCarouselContainer: {
        display: 'flex',
        flexDirection: 'column',
        gap: `${gapBetweenHeaderAndItems}px`,
        marginLeft: `${sideMargin ?? 0}px`,
        marginRight: `${sideMargin ?? 0}px`
    },
    carouselContainer: {
        position: 'relative',
        [`& .${scrollArrowBaseClassName}`]: {
            position: 'absolute',
            top: 'calc(50% - (40px / 2))',
            width: '40px',
            height: '40px',
            borderRadius: '50%',
            display: 'none',
            justifyContent: 'center',
            alignItems: 'center',
            cursor: 'pointer',
            zIndex: 5,
            ...(scrollArrowBackgroundColor && {
                backgroundColor: scrollArrowBackgroundColor
            }),
            ...(scrollArrowBoxShadowColor && {
                boxShadow: `0px 0px 4px 0px ${scrollArrowBoxShadowColor}`
            }),
            [`&.${scrollArrowPrevClassName}`]: {
                left: '-10px'
            },
            [`&.${scrollArrowNextClassName}`]: {
                right: '-10px'
            },
            opacity: 0.9,
            '&:hover': {
                opacity: 1
            },
            /*
             * Should it hide buttons:
             * Mouse (pointer fine): no
             * Keyboard (pointer none): no
             * Finger (pointer coarse): yes
             * See also: https://developer.mozilla.org/en-US/docs/Web/CSS/@media/pointer
             * Basically this means "if the primary is touch, and they don't have any mouse, hide the buttons."
             * We do this so the buttons still show if a keyboard is plugged in.
             */
            '@media (pointer: coarse) and (not (any-pointer: fine))': {
                display: 'none'
            }
        },
        '&:hover': {
            [`& .${scrollArrowBaseClassName}`]: {
                display: 'flex'
            }
        }
    },
    carousel: {
        display: 'flex',
        overflowX: 'hidden',
        scrollSnapType: 'x mandatory',
        scrollBehavior: 'smooth',
        gap: `${columnGap ?? 0}px`,
        /*
         * See comment above about this pointer media query
         */
        '@media (pointer: coarse) and (not (any-pointer: fine))': {
            overflowX: 'auto',
            WebkitOverflowScrolling: 'touch',
            msOverflowStyle: 'none',
            scrollbarWidth: 'none',
            '&::-webkit-scrollbar': {
                display: 'none'
            }
        }
    },
    carouselItem: {
        width: itemWidth,
        height: 'auto',
        flexShrink: 0
    }
}));
const CollectionCarousel = ({ itemsContainerRef, items, renderItem, collectionItemSize, updateItemsPerRow, layoutOverrides, headerComponent, gapBetweenHeaderAndItems, isHorizontalScrollEnabled, scrollArrowBackgroundColor, scrollArrowBoxShadowColor, thresholdFromEnd, onReachedThresholdFromEnd, reportHorizontalScrollTelemetry }) => {
    const [carouselRef, carouselWidth] = useElementWidthResizeObserver();
    const { numColumns, fractionalItemAmount, columnGap, sideMargin } = useCollectionLayoutParams(collectionItemSize, carouselWidth, layoutOverrides ?? {});
    useEffect(() => {
        if (updateItemsPerRow) {
            updateItemsPerRow(numColumns);
        }
    }, [updateItemsPerRow, numColumns]);
    const shouldUseHorizontalScroll = isHorizontalScrollEnabled && items.length > numColumns;
    const itemWidth = useMemo(() => {
        if (carouselWidth && numColumns > 0) {
            const numTilesToFit = shouldUseHorizontalScroll
                ? numColumns + fractionalItemAmount
                : numColumns;
            return (carouselWidth - (columnGap ?? 0) * (Math.ceil(numTilesToFit) - 1)) / numTilesToFit;
        }
        return 0;
    }, [carouselWidth, shouldUseHorizontalScroll, numColumns, fractionalItemAmount, columnGap]);
    const { carouselScrollRef, isScrollBackDisabled, isScrollForwardDisabled, handleScrollBackClick, handleScrollForwardClick, getIsTileVisible } = useCarouselHorizontalScroll(shouldUseHorizontalScroll, itemWidth, carouselWidth, numColumns, columnGap, items.length, thresholdFromEnd, onReachedThresholdFromEnd, reportHorizontalScrollTelemetry);
    const scrollArrowBaseClassName = 'scroll-arrow';
    const scrollArrowPrevClassName = 'prev';
    const scrollArrowNextClassName = 'next';
    const { classes: { collectionCarouselContainer, carouselContainer, carousel, carouselItem } } = useStyles$h({
        itemWidth,
        columnGap,
        sideMargin,
        gapBetweenHeaderAndItems,
        scrollArrowBackgroundColor,
        scrollArrowBoxShadowColor,
        scrollArrowBaseClassName,
        scrollArrowPrevClassName,
        scrollArrowNextClassName
    });
    return (React.createElement("div", { className: collectionCarouselContainer },
        headerComponent,
        React.createElement("div", { ref: carouselRef, className: carouselContainer },
            React.createElement("div", { 
                // Merge the ref used for scrolling with the ref used for impressions, which must be the direct parent of the items
                ref: mergeRefs([carouselScrollRef, itemsContainerRef]), className: carousel }, items.map((item, itemIndex) => {
                return (React.createElement("div", { 
                    // eslint-disable-next-line react/no-array-index-key
                    key: itemIndex, id: 'collection-carousel-item', className: carouselItem }, renderItem(item, itemIndex, getIsTileVisible(itemIndex))));
            })),
            shouldUseHorizontalScroll && (React.createElement(ScrollArrows, { isScrollBackDisabled: isScrollBackDisabled, isScrollForwardDisabled: isScrollForwardDisabled, onScrollBack: handleScrollBackClick, onScrollForward: handleScrollForwardClick, scrollBackArrowClassName: classNames(scrollArrowBaseClassName, scrollArrowPrevClassName), scrollForwardArrowClassName: classNames(scrollArrowBaseClassName, scrollArrowNextClassName) })))));
};

const useStyles$g = makeStyles()((_theme, { itemWidth, columnGap, sideMargin, gapBetweenHeaderAndItems }) => ({
    collectionGridContainer: {
        display: 'flex',
        flexDirection: 'column',
        gap: `${gapBetweenHeaderAndItems}px`,
        marginLeft: `${sideMargin ?? 0}px`,
        marginRight: `${sideMargin ?? 0}px`
    },
    grid: {
        display: 'flex',
        flexDirection: 'row',
        flexWrap: 'wrap',
        gap: `${columnGap ?? 0}px`
    },
    gridItem: {
        width: itemWidth,
        height: 'auto'
    }
}));
const CollectionGrid = ({ itemsContainerRef, items, renderItem, collectionItemSize, updateItemsPerRow, layoutOverrides, headerComponent, gapBetweenHeaderAndItems }) => {
    const [gridRef, gridWidth] = useElementWidthResizeObserver();
    const { numColumns, columnGap, sideMargin } = useCollectionLayoutParams(collectionItemSize, gridWidth, layoutOverrides ?? {});
    useEffect(() => {
        if (updateItemsPerRow) {
            updateItemsPerRow(numColumns);
        }
    }, [updateItemsPerRow, numColumns]);
    const itemWidth = useMemo(() => {
        if (gridWidth && numColumns > 0) {
            return (gridWidth - (columnGap ?? 0) * (Math.ceil(numColumns) - 1)) / numColumns;
        }
        return 0;
    }, [gridWidth, numColumns, columnGap]);
    const { classes: { collectionGridContainer, grid, gridItem } } = useStyles$g({
        itemWidth,
        columnGap,
        sideMargin,
        gapBetweenHeaderAndItems
    });
    return (React.createElement("div", { className: collectionGridContainer },
        headerComponent,
        React.createElement("div", { ref: mergeRefs([gridRef, itemsContainerRef]), className: grid }, items.map((item, itemIndex) => {
            return (
            // eslint-disable-next-line react/no-array-index-key
            React.createElement("div", { key: itemIndex, id: 'collection-grid-item', className: gridItem }, renderItem(item, itemIndex)));
        }))));
};

// Global CSS transition configuration
const transitionConfig = {
    duration: '0.3s',
    easing: 'cubic-bezier(0.45, 0, 0, 1)'
};
const overrideDefaultButtonStyles = {
    backgroundColor: 'transparent',
    border: 'none',
    padding: 0,
    font: 'inherit',
    cursor: 'pointer',
    outline: 'none',
    textAlign: 'start'
};
const textTruncationStyles = {
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    wordWrap: 'break-word'
};
const textTruncationStylesWithWrap = {
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    wordWrap: 'break-word'
};

const useStyles$f = makeStyles()(() => ({
    linkContainerOverride: {
        // Override default <a> tag styles
        color: 'inherit',
        textDecoration: 'none',
        '&:hover': {
            textDecoration: 'none'
        },
        // Leave cursor: pointer to indicate that the link is clickable
        cursor: 'pointer'
    },
    buttonContainerOverride: {
        ...overrideDefaultButtonStyles
    }
}));
/**
 * If a linkPath is specified, the container element will be an <a> tag.
 * If a callback is specified but no linkPath, the container element will be a <button> tag.
 * If neither a linkPath nor callback are specified, the container element will be a <div>.
 *
 * Note that if both a linkPath and callback are specified, the callback will be called on link click.
 */
const MaybeLinkActionWrapper = ({ containerClassName, callback, linkPath, ariaLabel, openInNewTab, tabIndex, onFocus, onFocusLost, dataTestId, children }) => {
    const { classes: { linkContainerOverride, buttonContainerOverride } } = useStyles$f({});
    if (linkPath) {
        return (React.createElement("a", { href: linkPath, target: openInNewTab ? '_blank' : undefined, onClick: e => {
                e.stopPropagation();
                if (callback) {
                    callback();
                }
            }, onKeyDown: e => {
                if (e.code === keyBoardEventCode.enter) {
                    e.stopPropagation();
                    if (callback) {
                        callback();
                    }
                }
            }, className: classNames(containerClassName, linkContainerOverride), "aria-label": ariaLabel, tabIndex: tabIndex, onFocus: onFocus, onMouseOver: onFocus, onBlur: onFocusLost, onMouseLeave: onFocusLost, "data-testid": dataTestId, rel: 'noreferrer' }, children));
    }
    if (callback) {
        return (React.createElement("button", { type: 'button', onClick: e => {
                e.stopPropagation();
                e.preventDefault();
                callback();
            }, onKeyDown: e => {
                if (e.code === keyBoardEventCode.enter) {
                    e.stopPropagation();
                    e.preventDefault();
                    callback();
                }
            }, className: classNames(containerClassName, buttonContainerOverride), "aria-label": ariaLabel, tabIndex: tabIndex, onFocus: onFocus, onMouseOver: onFocus, onBlur: onFocusLost, onMouseLeave: onFocusLost, "data-testid": dataTestId }, children));
    }
    return (React.createElement("div", { className: containerClassName, "aria-label": ariaLabel, tabIndex: tabIndex, onFocus: onFocus, onMouseOver: onFocus, onBlur: onFocusLost, onMouseLeave: onFocusLost, "data-testid": dataTestId }, children));
};

// Generate dynamic nth-child selectors for z-index to create overlapping facepile
const generateChildZIndexStyles = (maxIndex) => {
    const styles = {};
    for (let i = 1; i <= maxIndex; i += 1) {
        styles[`&:nth-child(${i})`] = {
            zIndex: maxIndex - i + 1
        };
    }
    return styles;
};
const AVATAR_ICON_RING_PADDING = 2;
const useStyles$e = makeStyles()((_theme, { iconWidth, avatarContainerBackgroundColor, avatarImageBackgroundColor, avatarBorderColor, maxZIndex }) => ({
    facepileContainer: {
        width: 'fit-content',
        display: 'flex',
        alignItems: 'center'
    },
    avatarContainer: {
        // Create stacking effect by offsetting the right margin of each avatar container
        marginRight: `-${(iconWidth + 2 * AVATAR_ICON_RING_PADDING) / 2}px`,
        ...generateChildZIndexStyles(maxZIndex),
        '&:last-child': {
            marginRight: 0
        },
        // Avatar Thumbnail Container span
        '& span': {
            width: iconWidth + 2 * AVATAR_ICON_RING_PADDING,
            height: iconWidth + 2 * AVATAR_ICON_RING_PADDING,
            padding: `${AVATAR_ICON_RING_PADDING}px`,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: avatarContainerBackgroundColor
        },
        // Avatar Thumbnail img
        '& img': {
            width: iconWidth,
            height: iconWidth,
            objectFit: 'cover',
            borderRadius: '50%',
            backgroundColor: avatarImageBackgroundColor,
            border: `1px solid ${avatarBorderColor}`
        }
    }
}));
/**
 * Renders a stacked facepile of avatar thumbnails.
 */
const GameTileActiveFriendsFacepile = ({ avatarThumbnails, iconWidth, avatarContainerBackgroundColor, avatarImageBackgroundColor, avatarBorderColor }) => {
    const { classes: { facepileContainer, avatarContainer } } = useStyles$e({
        iconWidth,
        avatarContainerBackgroundColor,
        avatarImageBackgroundColor,
        avatarBorderColor,
        maxZIndex: avatarThumbnails.length
    });
    return (React.createElement("div", { className: facepileContainer }, avatarThumbnails.map(avatarThumbnail => (React.createElement("div", { key: avatarThumbnail.key, className: avatarContainer }, avatarThumbnail)))));
};

const useStyles$d = makeStyles()((_theme, { color, width, iconOverrideStyles }) => ({
    iconBaseStyles: {
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        color,
        width: `${width}px`,
        height: `${width}px`
    },
    iconOverride: {
        ...iconOverrideStyles
    }
}));
const Icon = ({ iconClassName, color, width, iconOverrideStyles }) => {
    const { classes: { iconBaseStyles, iconOverride } } = useStyles$d({ color, width, iconOverrideStyles: iconOverrideStyles || {} });
    return (React.createElement("span", { className: classNames(iconBaseStyles, iconOverride, iconClassName), "data-testid": 'icon-component' }));
};

var TAutomaticSize;
(function (TAutomaticSize) {
    TAutomaticSize["None"] = "None";
    TAutomaticSize["X"] = "X";
    TAutomaticSize["Y"] = "Y";
    TAutomaticSize["XY"] = "XY";
})(TAutomaticSize || (TAutomaticSize = {}));

function guiPropsToStyle(props) {
    const style = {};
    if (props === undefined) {
        return style;
    }
    if (props.layoutOrder !== undefined) {
        style.order = props.layoutOrder;
    }
    if (props.anchorPoint !== undefined) {
        style.transformOrigin = `${props.anchorPoint.x * 100}% ${props.anchorPoint.y * 100}%`;
    }
    if (props.automaticSize !== undefined) {
        if (props.automaticSize === TAutomaticSize.XY) {
            style.width = 'auto';
            style.height = 'auto';
        }
        else if (props.automaticSize === TAutomaticSize.X) {
            style.width = 'auto';
        }
        else if (props.automaticSize === TAutomaticSize.Y) {
            style.height = 'auto';
        }
    }
    if (props.size !== undefined) {
        style.width = `calc(${props.size.xScale * 100}% + ${props.size.xOffset}px)`;
        style.height = `calc(${props.size.yScale * 100}% + ${props.size.yOffset}px)`;
    }
    if (props.position !== undefined) {
        style.position = 'absolute';
        style.left = `calc(${props.position.xScale * 100}% + ${props.position.xOffset}px)`;
        style.top = `calc(${props.position.yScale * 100}% + ${props.position.yOffset}px)`;
        const anchorX = props.anchorPoint?.x ?? 0;
        const anchorY = props.anchorPoint?.y ?? 0;
        if (anchorX !== 0 || anchorY !== 0) {
            style.transform = `translate(-${anchorX * 100}%, -${anchorY * 100}%)`;
        }
    }
    if (props.zIndex !== undefined) {
        style.zIndex = props.zIndex;
    }
    return style;
}

const { linkStart: linkStartDelimiter, linkEnd: linkEndDelimiter, lineBreak: lineBreakDelimiter } = textFormatDelimiters;
/**
 * Helper function to format links in a paragraph if link delimiters are present.
 *
 * @returns linkContentParts: React node output that includes new styling for links.
 * @returns linkLabelPart: Cleansed text output without the delimeters for the aria-label.
 * @returns isProcessed: boolean to indicate if the link formatting was successfully processed.
 */
function formatLinkInParagraph(paragraph, linkToWrap = undefined, openLinkInNewTab = false) {
    const startIdx = paragraph.indexOf(linkStartDelimiter);
    const endIdx = paragraph.indexOf(linkEndDelimiter, startIdx + linkStartDelimiter.length);
    const hasValidLinkDelimiters = startIdx !== -1 && endIdx !== -1 && startIdx < endIdx;
    if (!hasValidLinkDelimiters) {
        return { linkContentParts: [paragraph], linkLabelPart: paragraph, isProcessed: false };
    }
    const prefix = paragraph.slice(0, startIdx);
    const linkText = paragraph.slice(startIdx + linkStartDelimiter.length, endIdx);
    const suffix = paragraph.slice(endIdx + linkEndDelimiter.length);
    const linkContentParts = [];
    if (prefix) {
        linkContentParts.push(prefix);
    }
    const linkElement = (React.createElement("b", null,
        React.createElement("u", null, linkText)));
    if (linkToWrap) {
        linkContentParts.push(React.createElement(MaybeLinkActionWrapper, { callback: undefined, linkPath: linkToWrap, ariaLabel: linkText, openInNewTab: openLinkInNewTab, dataTestId: 'link-action-wrapper' }, linkElement));
    }
    else {
        linkContentParts.push(linkElement);
    }
    if (suffix) {
        linkContentParts.push(suffix);
    }
    return { linkContentParts, linkLabelPart: `${prefix}${linkText}${suffix}`, isProcessed: true };
}
/**
 * Adds formatting if necessary to a text string that may include delimiters:
 * link decoration (bold/underline styling for the link text) if a text string includes linkStart and linkEnd delimiters, makes link clickable if linkToWrap is provided
 * line break if a text string includes a newLine delimiter
 *
 * @returns parsedTextContent: React node output that includes new styling for text.
 * @returns cleansedTextLabel: Cleansed text output without the delimeters for the aria-label.
 */
const useFormatText = (text, linkToWrap = undefined, openLinkInNewTab = false) => {
    return useMemo(() => {
        if (!text) {
            return {
                parsedTextContent: '',
                cleansedTextLabel: ''
            };
        }
        const textContentParts = [];
        const textLabelParts = [];
        let isLinkProcessed = false;
        const paragraphs = text.split(lineBreakDelimiter);
        paragraphs.forEach((paragraph, idx) => {
            // add break if not the first paragraph
            if (idx > 0) {
                textContentParts.push(React.createElement("br", null));
            }
            // add link decoration if needed and not already processed
            if (!isLinkProcessed) {
                const { linkContentParts, linkLabelPart, isProcessed } = formatLinkInParagraph(paragraph, linkToWrap, openLinkInNewTab);
                textContentParts.push(...linkContentParts);
                textLabelParts.push(linkLabelPart);
                isLinkProcessed = isProcessed;
            }
            // if no link decoration needed or already processed, just add the paragraph
            else {
                textContentParts.push(paragraph);
                textLabelParts.push(paragraph);
            }
        });
        return {
            parsedTextContent: React.createElement(React.Fragment, null, textContentParts),
            cleansedTextLabel: textLabelParts.join('')
        };
    }, [text, linkToWrap, openLinkInNewTab]);
};

const useStyles$c = makeStyles()((_theme, { gap, textColor, fontStyle, containerOverrideStyles, textOverrideStyles }) => ({
    textIconRow: {
        display: 'inline-flex',
        alignItems: 'center',
        gap: `${gap}px`,
        border: 'none',
        margin: '0px',
        padding: '0px',
        backgroundColor: 'transparent',
        appearance: 'none',
        width: '100%',
        ...containerOverrideStyles
    },
    textIconRowText: {
        ...textTruncationStyles,
        ...getTextStyles(defaultTextDataAttributeConfig, textColor, fontStyle)
    },
    textOverride: {
        flexShrink: 1,
        minWidth: 0,
        ...textOverrideStyles
    },
    iconBaseStyles: {
        flexShrink: 0
    }
}));
const TextIconRow = ({ onActivated, linkPath, text, textColor, fontStyle, gap = 0, iconClassName, iconWidth, iconColor, iconFirst = false, containerOverrides, textOverrides, iconOverrides }) => {
    const containerOverrideStyles = useMemo(() => {
        if (containerOverrides) {
            return guiPropsToStyle(containerOverrides);
        }
        return {};
    }, [containerOverrides]);
    const textOverrideStyles = useMemo(() => {
        if (textOverrides) {
            return guiPropsToStyle(textOverrides);
        }
        return {};
    }, [textOverrides]);
    const iconOverrideStyles = useMemo(() => {
        if (iconOverrides) {
            return guiPropsToStyle(iconOverrides);
        }
        return {};
    }, [iconOverrides]);
    const { classes: { textIconRow, textIconRowText, textOverride, iconBaseStyles } } = useStyles$c({
        gap,
        textColor,
        fontStyle,
        containerOverrideStyles,
        textOverrideStyles
    });
    const { parsedTextContent, cleansedTextLabel } = useFormatText(text);
    const textElement = useMemo(() => {
        return (React.createElement("span", { className: classNames(textIconRowText, textOverride), "data-testid": 'text-icon-row-text', ...getTextDataAttribute(defaultTextDataAttributeConfig) }, parsedTextContent));
    }, [parsedTextContent, textIconRowText, textOverride]);
    const textHeight = fontStyle.LineHeight * fontStyle.FontSize;
    // Default icon color and width to text color and height
    const derivedIconColor = iconColor ?? textColor;
    const derivedIconWidth = iconWidth ?? textHeight;
    const iconElement = useMemo(() => {
        if (iconClassName) {
            return (React.createElement(Icon, { iconClassName: classNames(iconBaseStyles, iconClassName), color: derivedIconColor, width: derivedIconWidth, iconOverrideStyles: iconOverrideStyles }));
        }
        return null;
    }, [derivedIconColor, derivedIconWidth, iconBaseStyles, iconClassName, iconOverrideStyles]);
    const textIconRowContent = iconFirst ? (React.createElement(React.Fragment, null,
        iconElement,
        textElement)) : (React.createElement(React.Fragment, null,
        textElement,
        iconElement));
    return (React.createElement(MaybeLinkActionWrapper, { containerClassName: textIconRow, callback: onActivated, linkPath: linkPath, ariaLabel: cleansedTextLabel, dataTestId: 'text-icon-row' }, textIconRowContent));
};

const oneMinuteInSeconds = 60;
const oneHourInSeconds = 60 * oneMinuteInSeconds;
const oneDayInSeconds = 24 * oneHourInSeconds;
const oneSecondInMilliseconds = 1000;
const defaultUpdateFrequency = 15 * oneSecondInMilliseconds;
const calculateCountdownTime = (timeRemainingSecs) => {
    if (timeRemainingSecs < 0) {
        return { days: 0, hours: 0, minutes: -1 };
    }
    // Buffer the calculation so we have e.g. "1m left" when 30s time remaining
    let remainingSecs = timeRemainingSecs + oneMinuteInSeconds - 1;
    let days = 0;
    let hours = 0;
    let minutes = 0;
    if (remainingSecs >= oneDayInSeconds) {
        days = Math.floor(remainingSecs / oneDayInSeconds);
        remainingSecs -= days * oneDayInSeconds;
    }
    if (remainingSecs >= oneHourInSeconds) {
        hours = Math.floor(remainingSecs / oneHourInSeconds);
        remainingSecs -= hours * oneHourInSeconds;
    }
    if (remainingSecs >= 0) {
        minutes = Math.floor(remainingSecs / oneMinuteInSeconds);
    }
    return { days, hours, minutes };
};
const validateTimeValues = (timeValues) => {
    if (timeValues.days < 0) {
        return false;
    }
    if (timeValues.hours < 0 || timeValues.hours > 23) {
        return false;
    }
    if (timeValues.minutes < 0 || timeValues.minutes > 59) {
        return false;
    }
    return true;
};
// Update more frequently when time is running out
const getUpdateFrequency = (timeRemainingSecs) => {
    if (timeRemainingSecs < oneMinuteInSeconds) {
        return oneSecondInMilliseconds;
    }
    return defaultUpdateFrequency;
};
const useCountdownText = ({ endTimestamp, formatStringHoursMinutes, defaultString }) => {
    const [countdownText, setCountdownText] = useState('');
    const [updateFrequency, setUpdateFrequency] = useState(defaultUpdateFrequency);
    const checkAndUpdateText = useCallback(() => {
        if (defaultString && endTimestamp !== undefined && formatStringHoursMinutes) {
            const now = Date.now() / 1000;
            const timeRemainingSecs = endTimestamp - now;
            const timeValues = calculateCountdownTime(timeRemainingSecs);
            const frequency = getUpdateFrequency(timeRemainingSecs);
            setUpdateFrequency(frequency);
            if (validateTimeValues(timeValues) && timeValues.days === 0) {
                const formattedText = formatStringHoursMinutes
                    .replace('{hours}', timeValues.hours.toString())
                    .replace('{minutes}', timeValues.minutes.toString());
                setCountdownText(formattedText);
            }
            else {
                setCountdownText(defaultString);
            }
            return;
        }
        if (defaultString) {
            setCountdownText(defaultString);
            return;
        }
        setCountdownText('');
    }, [defaultString, endTimestamp, formatStringHoursMinutes]);
    useEffect(() => {
        checkAndUpdateText();
    }, [checkAndUpdateText]);
    useEffect(() => {
        if (defaultString && endTimestamp !== undefined && formatStringHoursMinutes) {
            const now = Date.now() / 1000;
            const timeRemainingSecs = endTimestamp - now;
            if (timeRemainingSecs > 0) {
                const timer = setInterval(() => {
                    checkAndUpdateText();
                }, updateFrequency);
                return () => clearInterval(timer);
            }
        }
        return undefined;
    }, [updateFrequency, defaultString, endTimestamp, formatStringHoursMinutes, checkAndUpdateText]);
    return countdownText;
};

const CountdownTextIconRow = ({ endTimestamp, formatStringHoursMinutes, defaultString, onActivated, linkPath, textColor, fontStyle, gap = 0, iconClassName, iconWidth, iconColor, iconFirst = false, containerOverrides, textOverrides, iconOverrides }) => {
    const countdownText = useCountdownText({ endTimestamp, formatStringHoursMinutes, defaultString });
    return (React.createElement(TextIconRow, { onActivated: onActivated, linkPath: linkPath, text: countdownText, textColor: textColor, fontStyle: fontStyle, gap: gap, iconClassName: iconClassName, iconWidth: iconWidth, iconColor: iconColor, iconFirst: iconFirst, containerOverrides: containerOverrides, textOverrides: textOverrides, iconOverrides: iconOverrides }));
};

const useStyle$4 = makeStyles({
    name: 'Gradient'
})((_theme, { linearGradient, height, width }) => ({
    gradient: {
        position: 'absolute',
        bottom: 0,
        left: 0,
        ...(linearGradient && {
            width,
            height,
            background: linearGradient
        })
    }
}));
const Gradient = ({ gradient }) => {
    const { startColor, endColor, startTransparency, endTransparency, degree, heightPercent = 1, widthPercent = 1, midpointPercent = 0.5 } = gradient;
    // Add 90 degrees to account for lua gradient direction
    const luaDegree = (degree + 90) % 360;
    const startOpacity = 1 - startTransparency;
    const endOpacity = 1 - endTransparency;
    const gradientHeightPercentString = `${heightPercent * 100}%`;
    const gradientWidthPercentString = `${widthPercent * 100}%`;
    const midpointPercentString = `${midpointPercent * 100}%`;
    const linearGradient = useMemo(() => {
        return `linear-gradient(${luaDegree}deg, ${startColor}${Math.round(startOpacity * 255)
            .toString(16)
            .padStart(2, '0')}, ${midpointPercentString}, ${endColor}${Math.round(endOpacity * 255)
            .toString(16)
            .padStart(2, '0')})`;
    }, [startColor, endColor, startOpacity, endOpacity, luaDegree, midpointPercentString]);
    const { classes } = useStyle$4({
        linearGradient,
        height: gradientHeightPercentString,
        width: gradientWidthPercentString
    });
    return React.createElement("div", { className: classes.gradient });
};

const useStyle$3 = makeStyles({
    name: 'ImageWithGradient'
})((_theme, { imageContainerHeight, borderRadius, imageAspectRatio }) => ({
    imageWithGradientWindow: {
        height: `${imageContainerHeight}px`,
        width: '100%',
        position: 'relative',
        overflow: 'hidden',
        borderRadius: `${borderRadius}px`,
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        flexDirection: 'column'
    },
    imageContainer: {
        aspectRatio: imageAspectRatio,
        minWidth: '100%',
        flex: 1
    }
}));
/**
 * ImageWithGradient component displays an image with a gradient background.
 *
 * @component
 * @param {React.ReactNode} image - The image to be displayed.
 * @param {number} imageContainerHeight - The height of the image window.
 * @param {string} imageAspectRatio - The aspect ratio of the image.
 * @param {TGradient} gradient - The gradient configuration on the image.
 * @param {string} borderRadius - The border radius of the image.
 *
 * @returns {JSX.Element} The rendered image with gradient component.
 *
 * @example
 * <ImageWithGradient
 *   image={<img src="image.jpg" alt="image" />}
 *   imageContainerHeight={100}
 *   imageAspectRatio="16/9"
 *   gradient={{
 *     startColor: '#000000',
 *     endColor: '#000000',
 *     startTransparency: 0.5,
 *     endTransparency: 0.5,
 *     degree: 45,
 *     heightPercent: 0.5,
 *     widthPercent: 0.5,
 *     midpointPercent: 0.5
 *   }}
 *   borderRadius="10px"
 * />
 */
const ImageWithGradient = ({ image, imageContainerHeight, imageAspectRatio, gradient, borderRadius = 0 }) => {
    const { classes } = useStyle$3({
        imageContainerHeight,
        borderRadius,
        imageAspectRatio
    });
    return (React.createElement("div", { className: classes.imageWithGradientWindow, "data-testid": 'image-with-gradient-window' },
        React.createElement("div", { className: classes.imageContainer, "data-testid": 'image-container' }, image),
        gradient && React.createElement(Gradient, { gradient: gradient })));
};

/**
 * CtaButton component renders a styled button that triggers a callback function when clicked.
 *
 * @component
 * @param {Object} props - The properties object.
 * @param {Function} props.onButtonClick - The callback function to be called when the button is clicked.
 * @param {boolean} [props.forceCompactView] - Optional flag to force the button to use a compact view.
 *
 * @returns {JSX.Element} The rendered button component.
 *
 * @example
 * // Example usage:
 * // <CtaButton onButtonClick={() => console.log('Button clicked!')} />
 *
 */
const CtaButton = ({ onButtonClick, forceCompactView = false }) => {
    const { classes: { ctaButton } } = makeStyles()(() => ({
        ctaButton: {
            color: 'white',
            backgroundColor: '#335FFF',
            '&:hover': {
                backgroundColor: '#335FFF'
            },
            width: '188px',
            borderRadius: '8px',
            ...(forceCompactView
                ? {
                    width: '60px'
                }
                : {}),
            '@media (max-width: 600px)': {
                width: '60px'
            },
            height: '40px'
        }
    }))();
    return (React.createElement(Button, { className: ctaButton, onClick: onButtonClick }, "Join"));
};

const HeroUnitGradient = ({ gradient, gradientHeightPercent, gradientWidthPercent }) => {
    const { startColor, endColor, startTransparency, endTransparency, degree } = gradient;
    // Add 90 degrees to account for lua gradient direction
    const luaDegree = (degree + 90) % 360;
    const startOpacity = 1 - startTransparency;
    const endOpacity = 1 - endTransparency;
    const gradientHeightPercentString = `${gradientHeightPercent * 100}%`;
    const gradientWidthPercentString = `${gradientWidthPercent * 100}%`;
    const linearGradient = useMemo(() => {
        return `linear-gradient(${luaDegree}deg, ${startColor}${Math.round(startOpacity * 255)
            .toString(16)
            .padStart(2, '0')}, ${endColor}${Math.round(endOpacity * 255)
            .toString(16)
            .padStart(2, '0')})`;
    }, [startColor, endColor, startOpacity, endOpacity, luaDegree]);
    const { classes: { heroUnitGradient } } = makeStyles()(() => ({
        heroUnitGradient: {
            bottom: '0px',
            left: '0px',
            position: 'absolute'
        }
    }))();
    return (React.createElement("div", { style: {
            background: linearGradient,
            width: gradientWidthPercentString,
            height: gradientHeightPercentString
        }, className: heroUnitGradient }));
};

const foregroundParallaxLarge = 24;
const foregroundParallaxSmall = 16;
const heroUnitContentHeight = 336;
const textDropShadow = '2px 2px 4px rgba(0, 0, 0, 0.15)';
const defaultTitleImageHeightPercentCompact1x1 = 0.26;
const defaultTitleImageHeightPercentLarge1x1 = 0.3;
const defaultTitleImageHeightPercentCompact3x1 = 0.16;
const defaultTitleImageHeightPercentLarge3x1 = 0.2;

const useStyles$b = makeStyles()((_theme, { hasTitleImage, forceSmallView, forceMediumView, forceSmallOrMediumView, minCardHeight, titleImageHeightPercentLarge, titleImageHeightPercentCompact, titleImageAspectRatio }) => ({
    heroUnitContentContainer: {
        minHeight: `${minCardHeight}px`,
        height: `${heroUnitContentHeight}px`,
        width: '100%',
        position: 'relative',
        display: 'flex',
        overflow: 'hidden',
        borderRadius: '8px',
        flexDirection: 'column',
        justifyContent: 'flex-end',
        padding: '20px',
        ...(forceSmallOrMediumView
            ? {
                padding: '16px',
                aspectRatio: '16 / 9',
                height: 'auto'
            }
            : {}),
        '@media (max-width: 600px)': {
            padding: '16px',
            aspectRatio: '16 / 9',
            height: 'auto'
        }
    },
    heroUnitTitleContainer: {
        position: 'absolute',
        top: '50%',
        transform: 'translateY(-50%)',
        display: 'flex',
        flexDirection: 'column',
        width: '100%'
    },
    heroUnitTitle: {
        color: 'white',
        position: 'relative',
        textShadow: `${textDropShadow}`,
        fontFamily: 'Builder Sans',
        fontSize: '40px',
        fontWeight: 700,
        lineHeight: '48px',
        ...(forceSmallOrMediumView
            ? {
                lineHeight: '28.8px'
            }
            : {}),
        ...(forceSmallView
            ? {
                fontSize: '24px'
            }
            : {}),
        ...(forceMediumView
            ? {
                fontSize: '28px'
            }
            : {}),
        '@media (max-width: 600px)': {
            lineHeight: '28.8px'
        },
        '@media (min-width: 415px) and (max-width: 600px)': {
            fontSize: '24px'
        },
        '@media (max-width: 414px)': {
            fontSize: '28px'
        }
    },
    heroUnitSubtitle: {
        color: 'white',
        textShadow: `${textDropShadow}`,
        marginTop: '2px',
        position: 'relative',
        fontFamily: 'Builder Sans',
        fontSize: '16px',
        fontWeight: 400,
        lineHeight: '24px',
        ...(!hasTitleImage &&
            forceSmallOrMediumView && {
            display: 'none'
        }),
        ...(!hasTitleImage && {
            '@media (max-width: 600px)': {
                display: 'none'
            }
        })
    },
    heroUnitTitleImageContainer: {
        position: 'absolute',
        height: `calc(var(--hero-unit-content-height) * ${titleImageHeightPercentLarge})`,
        width: `calc(var(--hero-unit-content-height) *${titleImageHeightPercentLarge} * ${titleImageAspectRatio})`,
        right: '20px',
        top: '20px',
        ...(forceSmallOrMediumView && {
            height: `calc(var(--hero-unit-content-height) * ${titleImageHeightPercentCompact})`,
            width: `calc(var(--hero-unit-content-height) *${titleImageHeightPercentCompact} * ${titleImageAspectRatio})`,
            right: '16px',
            top: '16px'
        }),
        '@media (max-width: 600px)': {
            height: `calc(var(--hero-unit-content-height) * ${titleImageHeightPercentCompact})`,
            width: `calc(var(--hero-unit-content-height) *${titleImageHeightPercentCompact} * ${titleImageAspectRatio})`,
            right: '16px',
            top: '16px'
        }
    }
}));
const HeroUnitContent = ({ title, subtitle, titleImageComponent, heroUnitRef, gradient, gradientHeightPercent, gradientWidthPercent, bottomRowComponent, overlayPillComponent, forceViewportWidth, titleImageAspectRatio = 3, titleImageHeightPercentage, minCardHeight }) => {
    const forceSmallView = forceViewportWidth !== undefined && forceViewportWidth <= 414;
    const forceMediumView = forceViewportWidth !== undefined && forceViewportWidth <= 600 && forceViewportWidth >= 415;
    const forceSmallOrMediumView = forceSmallView || forceMediumView;
    const fallbackTitleImageHeightPercentCompact = titleImageAspectRatio === 1
        ? defaultTitleImageHeightPercentCompact1x1
        : defaultTitleImageHeightPercentCompact3x1;
    const fallbackTitleImageHeightPercentLarge = titleImageAspectRatio === 1
        ? defaultTitleImageHeightPercentLarge1x1
        : defaultTitleImageHeightPercentLarge3x1;
    const titleImageHeightPercentCompact = titleImageHeightPercentage ?? fallbackTitleImageHeightPercentCompact;
    const titleImageHeightPercentLarge = titleImageHeightPercentage ?? fallbackTitleImageHeightPercentLarge;
    const { classes: { heroUnitContentContainer, heroUnitTitleContainer, heroUnitTitle, heroUnitSubtitle, heroUnitTitleImageContainer } } = useStyles$b({
        hasTitleImage: !!titleImageComponent,
        forceSmallView,
        forceMediumView,
        forceSmallOrMediumView,
        minCardHeight,
        titleImageHeightPercentLarge,
        titleImageHeightPercentCompact,
        titleImageAspectRatio
    });
    const updateContentHeightCssProp = useCallback(() => {
        if (heroUnitRef?.current) {
            heroUnitRef.current.style.setProperty('--hero-unit-content-height', `${heroUnitRef.current.getBoundingClientRect().height}px`);
        }
    }, [heroUnitRef]);
    useEffect(() => {
        const heroUnitRefCopy = heroUnitRef?.current;
        if (!heroUnitRefCopy)
            return;
        updateContentHeightCssProp();
        const resizeObserver = new ResizeObserver(throttle(updateContentHeightCssProp, 100));
        resizeObserver.observe(heroUnitRefCopy);
        // eslint-disable-next-line consistent-return
        return () => {
            resizeObserver.unobserve(heroUnitRefCopy);
        };
    }, [heroUnitRef, updateContentHeightCssProp]);
    return (React.createElement("div", { className: heroUnitContentContainer, ref: heroUnitRef },
        React.createElement(HeroUnitGradient, { gradient: gradient, gradientHeightPercent: gradientHeightPercent, gradientWidthPercent: gradientWidthPercent }),
        overlayPillComponent,
        titleImageComponent && (React.createElement("div", { className: heroUnitTitleImageContainer }, titleImageComponent)),
        React.createElement("div", { className: heroUnitTitleContainer },
            React.createElement("span", { className: heroUnitTitle }, title),
            React.createElement("span", { className: heroUnitSubtitle }, subtitle)),
        bottomRowComponent));
};

const useStyles$a = makeStyles()((_theme, { minCardHeight, forceSmallOrMediumView, enableBackgroundAnimation }) => ({
    heroUnitBackgroundWindow: {
        height: `${heroUnitContentHeight}px`,
        width: '100%',
        position: 'absolute',
        top: '24px',
        overflow: 'hidden',
        borderRadius: '8px',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        minHeight: `${minCardHeight}px`,
        ...(forceSmallOrMediumView
            ? {
                aspectRatio: '16 / 9',
                height: 'auto',
                top: '16px'
            }
            : {}),
        '@media (max-width: 600px)': {
            aspectRatio: '16 / 9',
            height: 'auto',
            top: '16px'
        }
    },
    heroUnitBackgroundContainer: {
        '--parallax-scale': '100',
        minWidth: 'max(100%, 1320px)',
        height: '436px',
        display: 'flex',
        flexDirection: 'column',
        ...(enableBackgroundAnimation && {
            transform: 'translateY(calc(var(--parallax-scale) * ((var(--scroll) * 1px) - 0.5px)))',
            // Disable parallax effect for users that prefer reduced motion
            '@media (prefers-reduced-motion)': {
                transform: 'translateY(0px)'
            }
        }),
        '@media (min-width: 1320px)': {
            height: 'auto'
        },
        ...(forceSmallOrMediumView
            ? {
                minHeight: 'calc(100% + 66px)',
                width: 'auto',
                '--parallax-scale': '66',
                '& img': {
                    objectFit: 'cover'
                }
            }
            : {}),
        '@media (max-width: 600px)': {
            minHeight: 'calc(100% + 66px)',
            width: 'auto',
            '--parallax-scale': '66',
            '& img': {
                objectFit: 'cover'
            }
        }
    }
}));
const HeroUnitBackground = ({ backgroundImageComponent, forceViewportWidth, minCardHeight, enableBackgroundAnimation }) => {
    const forceSmallOrMediumView = forceViewportWidth !== undefined && forceViewportWidth <= 600;
    const { classes: { heroUnitBackgroundWindow, heroUnitBackgroundContainer } } = useStyles$a({
        minCardHeight,
        forceSmallOrMediumView,
        enableBackgroundAnimation
    });
    return (React.createElement("div", { className: heroUnitBackgroundWindow },
        React.createElement("div", { className: heroUnitBackgroundContainer }, backgroundImageComponent)));
};

/* eslint-disable jsx-a11y/click-events-have-key-events */
/* eslint-disable jsx-a11y/no-static-element-interactions */
const useStyles$9 = makeStyles()((_theme, { forceViewportWidth, maxForegroundHeightPercentString, forceSmallOrMediumView, minForegroundHeightPercentString, foregroundScaleFactor, foregroundAspectRatio, enableForegroundAnimation }) => ({
    heroUnitContainer: {
        width: '100%',
        position: 'relative',
        display: 'flex',
        overflow: 'hidden',
        alignItems: 'center',
        flexDirection: 'column',
        cursor: 'pointer',
        margin: 'none',
        // image containers need images to fill them, so we set the width and height to 100%
        '& img': {
            width: '100%',
            height: '100%'
        },
        ...(forceViewportWidth
            ? {
                maxWidth: `${forceViewportWidth}px`
            }
            : {})
    },
    heroUnitForegroundContainer: {
        height: maxForegroundHeightPercentString,
        aspectRatio: `${foregroundAspectRatio}`,
        // this is the height of the foreground image if it were to take up the full width of the hero unit,
        // used as max height to prevent container overflow
        maxHeight: `calc(var(--hero-unit-container-width) / ${foregroundAspectRatio})`,
        display: 'flex',
        flexDirection: 'column',
        position: 'absolute',
        top: '0px',
        '--parallax-scale': `${foregroundParallaxLarge * 2}`,
        ...(enableForegroundAnimation && {
            transform: 'translateY(calc(var(--parallax-scale) * ((var(--scroll) * -1px) + 1px)))',
            '@media (prefers-reduced-motion)': {
                // Disable parallax effect for users that prefer reduced motion
                transform: 'translateY(0px)'
            }
        }),
        ...(forceSmallOrMediumView
            ? {
                height: minForegroundHeightPercentString,
                '--parallax-scale': `${foregroundParallaxSmall * 2}`
            }
            : {}),
        '@media (max-width: 600px)': {
            height: minForegroundHeightPercentString,
            '--parallax-scale': `${foregroundParallaxSmall * 2}`
        },
        '@media (min-width: 601px) and (max-width: 1140px)': {
            height: `calc(${minForegroundHeightPercentString} + ((${foregroundScaleFactor} * (100vw - 600px)) / 540))`
        }
    },
    heroUnitTopSpacer: {
        height: `${foregroundParallaxLarge}px`,
        ...(forceSmallOrMediumView ? { height: `${foregroundParallaxSmall}px` } : {}),
        '@media (max-width: 600px)': {
            height: `${foregroundParallaxSmall}px`
        }
    }
}));
/**
 * HeroUnit component
 *
 * This component renders a hero unit section with a background image, foreground image,
 * title, subtitle, badge text, gradient, experience information and a call-to-action button.
 * It also includes a parallax effect for the background and foreground images based on the
 * scroll position.
 *
 * @param {HeroUnitProps} props - The properties for the HeroUnit component.
 * @param {string} props.title - The title text for the hero unit.
 * @param {string} props.subtitle - The subtitle text for the hero unit.
 * @param {React.ReactNode} [props.titleImageComponent] - The title image component, which can be an img or <Thumbnail2d>. If present, overrides the title text with a title image.
 * @param {React.ReactNode} props.foregroundImageComponent - The foreground image component. Can be img or <Thumbnail2d>
 * @param {React.ReactNode} props.backgroundImageComponent - The background image component. Can be img or <Thumbnail2d>
 * @param {TGradient} props.gradient - The gradient overlay for the hero unit.
 * @param {number} [props.gradientHeightPercent=0.5] - The height of the gradient overlay as a percentage of the hero unit height.
 * @param {number} [props.gradientWidthPercent=1] - The width of the gradient overlay as a percentage of the hero unit width.
 * @param {() => void} [props.backgroundClickAction] - The action to perform when the background is clicked, if the action includes a callback.
 * @param {string} [props.backgroundClickLinkPath] - The path to navigate to when the background is clicked, if the action includes a link.
 * @param {React.ReactNode} props.bottomRowComponent - The component to render in the bottom row.
 * @param {React.ReactNode} props.overlayPillComponent - The component to render as an overlay pill.
 * @param {number} [props.minForegroundHeightPercent=0.8] - The minimum height of the foreground image as a percentage of the hero unit height.
 * @param {number} [props.maxForegroundHeightPercent=1] - The maximum height of the foreground image as a percentage of the hero unit height.
 * @param {boolean} [props.forceViewportWidth] - Forces the hero unit to render as if the screen was this width.
 * @param {number} [props.titleImageAspectRatio=3] - The aspect ratio of the title image.
 * @param {number} [props.titleImageHeightPercentage] - The height of the title image as a percentage of the hero unit height.
 * @param {number} [props.minCardHeight=262] - The minimum height of the hero unit card.
 * @param {number} [props.foregroundAspectRatio=1] - The aspect ratio of the foreground image.
 * @param {boolean} [props.enableBackgroundAnimation=true] - Whether to enable background animation.
 * @param {boolean} [props.enableForegroundAnimation=true] - Whether to enable foreground animation.
 *
 * @returns {JSX.Element} The rendered HeroUnit component.
 */
const HeroUnit = ({ title, subtitle, titleImageComponent, foregroundImageComponent, backgroundImageComponent, gradient, gradientHeightPercent = 0.5, gradientWidthPercent = 1, backgroundClickAction: onBackgroundClick, backgroundClickLinkPath, bottomRowComponent, overlayPillComponent, minForegroundHeightPercent = 0.8, maxForegroundHeightPercent = 1, forceViewportWidth, titleImageAspectRatio = 3, titleImageHeightPercentage, minCardHeight = 262, foregroundAspectRatio = 1, enableBackgroundAnimation = true, enableForegroundAnimation = true }) => {
    const isMidpointPositionFinalizedRef = React.useRef(false);
    const [normalizedInitialMidpointPosition, setNormalizedInitialMidpointPosition] = React.useState(1);
    const forceSmallOrMediumView = forceViewportWidth !== undefined && forceViewportWidth <= 600;
    const heroUnitContentRef = React.useRef(null);
    const heroUnitContainerRef = React.useRef(null);
    const minForegroundHeightPercentString = `${Math.round(minForegroundHeightPercent * 100)}%`;
    const maxForegroundHeightPercentString = `${Math.round(maxForegroundHeightPercent * 100)}%`;
    // this is the difference in pixels between the min and max foreground height. we use foreground parallax large because
    // this variable is only in use when screen width is between 600 and 1140px
    const foregroundScaleFactor = (maxForegroundHeightPercent - minForegroundHeightPercent) *
        (heroUnitContentHeight + foregroundParallaxLarge);
    const { classes: { heroUnitContainer, heroUnitForegroundContainer, heroUnitTopSpacer } } = useStyles$9({
        forceViewportWidth,
        maxForegroundHeightPercentString,
        forceSmallOrMediumView,
        minForegroundHeightPercentString,
        foregroundScaleFactor,
        foregroundAspectRatio,
        enableForegroundAnimation
    });
    // used to calculate the distance from top of hero unit to the bottom of the window, which
    // is used to calculate the transform of the background and foreground images for parallax
    const updateParallaxCss = useCallback(() => {
        const easeInOut = bezier(0.2, 0, 0.8, 1);
        if (!heroUnitContentRef.current || !window.innerHeight) {
            return;
        }
        let newNormalizedInitialMidpointPosition = normalizedInitialMidpointPosition;
        // if the midpoint position has not been finalized, calculate it on the fly
        if (!isMidpointPositionFinalizedRef.current) {
            // distance of hero unit midpoint to top of viewport
            const initialMidpointPosition = heroUnitContentRef.current.getBoundingClientRect().top + heroUnitContentHeight / 2;
            if (initialMidpointPosition <= 0) {
                // if the unit starts offscreen, parallax formula will be incorrect
                return;
            }
            newNormalizedInitialMidpointPosition =
                Math.min(initialMidpointPosition, window.innerHeight) / window.innerHeight;
            // bound to range [0, viewportHeight], then normalize to [0,1]
            setNormalizedInitialMidpointPosition(newNormalizedInitialMidpointPosition);
        }
        const rect = heroUnitContentRef.current.getBoundingClientRect();
        const normalizedDistanceFromTop = rect.top / window.innerHeight;
        // map normalized distance from top from [0, normalizedInitialMidpointPosition] to [0, 1]
        const scrollProgress = (newNormalizedInitialMidpointPosition - normalizedDistanceFromTop) /
            newNormalizedInitialMidpointPosition;
        // clamp to [0,1]
        const clampedScrollProgress = Math.max(Math.min(scrollProgress, 1), 0);
        const bezierEasied = easeInOut(clampedScrollProgress);
        if (heroUnitContainerRef.current) {
            heroUnitContainerRef.current.style.setProperty('--scroll', bezierEasied.toString());
            heroUnitContainerRef.current.style.setProperty('--hero-unit-container-width', `${rect.width}px`);
        }
    }, [heroUnitContentRef, isMidpointPositionFinalizedRef, normalizedInitialMidpointPosition]);
    // initial load of mutation observer and scroll/resize listeners
    useEffect(() => {
        // want to throttle the observer function because we don't care about smoothness like we do on scroll
        const updateParallaxCssThrottled = throttle(updateParallaxCss, 100);
        // until first scroll, listen for dom changes to recalculate parallax effect
        const observer = new MutationObserver(updateParallaxCssThrottled);
        // if first scroll hasn't happened yet, observe body to indirectly detect hero unit position change
        if (document.body && !isMidpointPositionFinalizedRef.current) {
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        }
        // inital parallax update
        updateParallaxCss();
        // finalize midpoint position after first scroll event
        const updateParallaxCssAndFinalizeMidpoint = () => {
            updateParallaxCss();
            isMidpointPositionFinalizedRef.current = true;
            observer.disconnect();
        };
        window.addEventListener('scroll', updateParallaxCssAndFinalizeMidpoint);
        window.addEventListener('resize', updateParallaxCssAndFinalizeMidpoint);
        return () => {
            window.removeEventListener('scroll', updateParallaxCssAndFinalizeMidpoint);
            window.removeEventListener('resize', updateParallaxCssAndFinalizeMidpoint);
            observer.disconnect();
        };
    }, [isMidpointPositionFinalizedRef, updateParallaxCss]);
    return (React.createElement("div", { ref: heroUnitContainerRef },
        React.createElement(MaybeLinkActionWrapper, { containerClassName: heroUnitContainer, callback: onBackgroundClick, linkPath: backgroundClickLinkPath, ariaLabel: title, dataTestId: 'hero-unit' },
            React.createElement("div", { className: heroUnitTopSpacer }),
            React.createElement(HeroUnitBackground, { backgroundImageComponent: backgroundImageComponent, forceViewportWidth: forceViewportWidth, minCardHeight: minCardHeight, enableBackgroundAnimation: enableBackgroundAnimation }),
            React.createElement("div", { className: heroUnitForegroundContainer }, foregroundImageComponent),
            React.createElement(HeroUnitContent, { title: title, subtitle: subtitle, titleImageComponent: titleImageComponent, heroUnitRef: heroUnitContentRef, gradient: gradient, gradientHeightPercent: gradientHeightPercent, gradientWidthPercent: gradientWidthPercent, bottomRowComponent: bottomRowComponent, overlayPillComponent: overlayPillComponent, forceViewportWidth: forceViewportWidth, titleImageAspectRatio: titleImageAspectRatio, titleImageHeightPercentage: titleImageHeightPercentage, minCardHeight: minCardHeight }))));
};

const useStyles$8 = makeStyles()((_theme, { textColor, fontStyle, containerOverrideStyles }) => ({
    labelTextSpan: {
        backgroundColor: 'transparent',
        ...getTextStyles(defaultTextDataAttributeConfig, textColor, fontStyle)
    },
    bottomRowContainer: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'flex-end',
        alignSelf: 'stretch',
        ...containerOverrideStyles
    }
}));
/*
  This component is built to be used as the bottomRowComponent prop for HeroUnit.
  It creates a stretched flexbox container with the CTA button on the left and
  rightContent on the right. The rightContent is the generic UI component
  rightLabelContent if provided, otherwise it is a span with labelText. If
  neither rightLabelContent nor labelText is provided, nothing is rendered on
  the right side.
*/
const HeroUnitBottomRow = ({ ctaButton, labelText, labelTextColor = 'white', labelTextFontStyle, rightLabelContent, containerOverrides }) => {
    const containerOverrideStyles = useMemo(() => {
        if (containerOverrides) {
            return guiPropsToStyle(containerOverrides);
        }
        return {};
    }, [containerOverrides]);
    const { classes: { labelTextSpan, bottomRowContainer } } = useStyles$8({
        textColor: labelTextColor,
        fontStyle: labelTextFontStyle,
        containerOverrideStyles
    });
    const rightContent = useMemo(() => {
        if (rightLabelContent) {
            return (React.createElement("div", { "data-testid": 'hero-unit-bottom-row-right-content-wrapper' }, rightLabelContent));
        }
        if (labelText) {
            return (React.createElement("span", { className: labelTextSpan, "data-testid": 'hero-unit-bottom-row-text', ...getTextDataAttribute(defaultTextDataAttributeConfig) }, labelText));
        }
        return null;
    }, [labelText, labelTextSpan, rightLabelContent]);
    return (React.createElement("div", { className: bottomRowContainer, "data-testid": 'hero-unit-bottom-row' },
        ctaButton,
        rightContent));
};

const OverlayPill = ({ pillText }) => {
    const { classes: { heroUnitPill, heroUnitPillText } } = makeStyles()(() => ({
        heroUnitPill: {
            width: '76px',
            height: '24px',
            borderRadius: '16px',
            backgroundColor: 'white',
            color: 'black',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            marginBottom: 'auto',
            zIndex: 10 // consistent with slotOverlay, pill should be on top of other content + gradient
        },
        heroUnitPillText: {
            fontFamily: 'Builder Sans',
            fontSize: '12px',
            fontWeight: 600,
            lineHeight: '12px'
        }
    }))();
    return (React.createElement("div", { className: heroUnitPill },
        React.createElement("span", { className: heroUnitPillText }, pillText)));
};

const useStyles$7 = makeStyles()((_theme, { verticalGap, containerOverrideStyles }) => ({
    sectionHeader: {
        position: 'relative',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        width: '100%',
        ...containerOverrideStyles
    },
    titleSubtitleContainer: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'flex-start',
        gap: `${verticalGap}px`,
        minWidth: 0,
        width: '100%'
    }
}));
const SectionHeader = ({ onTitleActivated, titleText, titleLinkPath, titleTextColor, titleFontStyle, titleGap, titleIconClassName, titleIconWidth, titleIconColor, titleIconFirst = false, titleComponent, onSubtitleActivated, subtitleLinkPath, subtitleText, subtitleTextColor, subtitleFontStyle, subtitleGap, subtitleIconClassName, subtitleIconWidth, subtitleIconColor, subtitleIconFirst = false, subtitleComponent, verticalGap = 0, 
// onInfoIconActivated,
// iconClassName,
// iconWidth = 16,
// infoText,
iconComponent, containerOverrides }) => {
    const containerOverrideStyles = useMemo(() => {
        if (containerOverrides) {
            return guiPropsToStyle(containerOverrides);
        }
        return {};
    }, [containerOverrides]);
    const { classes: { sectionHeader, titleSubtitleContainer } } = useStyles$7({
        verticalGap,
        containerOverrideStyles
    });
    const titleElement = useMemo(() => {
        if (titleComponent) {
            return titleComponent;
        }
        if (titleText !== undefined && titleTextColor !== undefined && titleFontStyle !== undefined) {
            return (React.createElement(TextIconRow, { text: titleText, textColor: titleTextColor, fontStyle: titleFontStyle, gap: titleGap, iconClassName: titleIconClassName, iconWidth: titleIconWidth, iconColor: titleIconColor, iconFirst: titleIconFirst }));
        }
        return null;
    }, [
        titleComponent,
        titleFontStyle,
        titleGap,
        titleIconClassName,
        titleIconColor,
        titleIconFirst,
        titleIconWidth,
        titleText,
        titleTextColor
    ]);
    const subtitleElement = useMemo(() => {
        if (subtitleComponent) {
            return subtitleComponent;
        }
        if (subtitleText !== undefined &&
            subtitleTextColor !== undefined &&
            subtitleFontStyle !== undefined) {
            return (React.createElement(TextIconRow, { onActivated: onSubtitleActivated, linkPath: subtitleLinkPath, text: subtitleText, textColor: subtitleTextColor, fontStyle: subtitleFontStyle, gap: subtitleGap, iconClassName: subtitleIconClassName, iconWidth: subtitleIconWidth, iconColor: subtitleIconColor, iconFirst: subtitleIconFirst }));
        }
        return null;
    }, [
        onSubtitleActivated,
        subtitleLinkPath,
        subtitleComponent,
        subtitleFontStyle,
        subtitleGap,
        subtitleIconClassName,
        subtitleIconColor,
        subtitleIconFirst,
        subtitleIconWidth,
        subtitleText,
        subtitleTextColor
    ]);
    const infoTooltipElement = iconComponent;
    const wrappedTitleSubtitleContent = useMemo(() => {
        return (React.createElement(MaybeLinkActionWrapper, { containerClassName: titleSubtitleContainer, callback: onTitleActivated, linkPath: titleLinkPath, ariaLabel: titleText, dataTestId: 'section-header-title-subtitle-container' },
            titleElement,
            subtitleElement));
    }, [
        onTitleActivated,
        subtitleElement,
        titleElement,
        titleLinkPath,
        titleSubtitleContainer,
        titleText
    ]);
    return (React.createElement("div", { className: sectionHeader, "data-testid": 'section-header' },
        wrappedTitleSubtitleContent,
        infoTooltipElement));
};

const Slots = {
    topLeftSlot: {
        anchorPoint: { x: 0, y: 0 },
        position: { xScale: 0, yScale: 0, xOffset: 0, yOffset: 0 }
    },
    topMiddleSlot: {
        anchorPoint: { x: 0.5, y: 0 },
        position: { xScale: 0.5, yScale: 0, xOffset: 0, yOffset: 0 }
    },
    topRightSlot: {
        anchorPoint: { x: 1, y: 0 },
        position: { xScale: 1, yScale: 0, xOffset: 0, yOffset: 0 }
    },
    centerLeftSlot: {
        anchorPoint: { x: 0, y: 0.5 },
        position: { xScale: 0, yScale: 0.5, xOffset: 0, yOffset: 0 }
    },
    centerMiddleSlot: {
        anchorPoint: { x: 0.5, y: 0.5 },
        position: { xScale: 0.5, yScale: 0.5, xOffset: 0, yOffset: 0 }
    },
    centerRightSlot: {
        anchorPoint: { x: 1, y: 0.5 },
        position: { xScale: 1, yScale: 0.5, xOffset: 0, yOffset: 0 }
    },
    bottomLeftSlot: {
        anchorPoint: { x: 0, y: 1 },
        position: { xScale: 0, yScale: 1, xOffset: 0, yOffset: 0 }
    },
    bottomMiddleSlot: {
        anchorPoint: { x: 0.5, y: 1 },
        position: { xScale: 0.5, yScale: 1, xOffset: 0, yOffset: 0 }
    },
    bottomRightSlot: {
        anchorPoint: { x: 1, y: 1 },
        position: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 }
    }
};
const slotKeys = Object.keys(Slots);
const getSlotStyle = (slotConfig) => {
    const style = {
        left: `${slotConfig.position.xScale * 100}%`,
        top: `${slotConfig.position.yScale * 100}%`,
        transform: `translate(-${slotConfig.anchorPoint.x * 100}%, -${slotConfig.anchorPoint.y * 100}%)`
    };
    return style;
};
const commonSlotWrapperStyles = {
    background: 'transparent',
    width: 'auto',
    height: 'auto',
    // Content should appear on top of game tile, invisible if zero
    zIndex: 10,
    // Make slot wrapper containers non-interactive
    pointerEvents: 'none',
    position: 'absolute'
};

const useStyles$6 = makeStyles()((_theme, { padding, containerOverrideStyles }) => {
    // Initialize an object to store CSS styles for each slot position (top-left, center, etc.).
    // Each slot is positioned absolutely. Shared styles come from commonSlotWrapperStyles.
    const slotStyleDefinitions = Object.keys(Slots).reduce((acc, slotKey) => {
        const key = slotKey;
        acc[key] = {
            ...commonSlotWrapperStyles,
            ...getSlotStyle(Slots[key]),
            padding: `${padding}px`
        };
        return acc;
    }, {});
    return {
        overlayContainer: {
            position: 'relative',
            boxSizing: 'border-box',
            width: '100%',
            height: '100%',
            background: 'transparent',
            overflow: 'hidden',
            display: 'block',
            ...containerOverrideStyles
        },
        ...slotStyleDefinitions
    };
});
const SlotOverlay = ({ topLeftSlot, topMiddleSlot, topRightSlot, centerLeftSlot, centerMiddleSlot, centerRightSlot, bottomLeftSlot, bottomMiddleSlot, bottomRightSlot, padding = 0, containerOverrides, children }) => {
    const containerOverrideStyles = useMemo(() => {
        if (containerOverrides) {
            return guiPropsToStyle(containerOverrides);
        }
        return {};
    }, [containerOverrides]);
    const { classes } = useStyles$6({ padding, containerOverrideStyles });
    const slotPropsMap = useMemo(() => {
        return {
            topLeftSlot,
            topMiddleSlot,
            topRightSlot,
            centerLeftSlot,
            centerMiddleSlot,
            centerRightSlot,
            bottomLeftSlot,
            bottomMiddleSlot,
            bottomRightSlot
        };
    }, [
        topLeftSlot,
        topMiddleSlot,
        topRightSlot,
        centerLeftSlot,
        centerMiddleSlot,
        centerRightSlot,
        bottomLeftSlot,
        bottomMiddleSlot,
        bottomRightSlot
    ]);
    const slotElements = useMemo(() => {
        return slotKeys
            .map(propName => {
            const slotContent = slotPropsMap[propName];
            if (slotContent) {
                const slotClassName = classes[propName];
                return (React.createElement("div", { key: propName, className: slotClassName, "data-testid": `slot-wrapper-${propName}` }, slotContent));
            }
            return null;
        })
            .filter(e => e !== null);
    }, [slotPropsMap, classes]);
    return (React.createElement("div", { className: classes.overlayContainer, "data-testid": 'slot-overlay-container' },
        children,
        slotElements));
};

const useStyles$5 = makeStyles()((_theme, { textFontStyle, textColor }) => ({
    textElement: {
        ...textTruncationStylesWithWrap,
        ...getTextStyles(defaultTextDataAttributeConfig, textColor, textFontStyle)
    }
}));
/**
 * Text component displays a block of text.
 *
 * @component
 * @param {string} text - The text to be displayed.
 * @param {TTypographyToken} textFontStyle - The font style of the text.
 * @param {string} textColor - The color of the text to be displayed.
 * @param {string} textLink - The clickable link for the text.
 * @param {boolean} openLinkInNewTab - The flag to open the link in a new tab, defaults to false if not provided.
 *
 * @example
 * <Text
 *   text="Sample Text. {lineBreak}{linkStart}Click Here!{linkEnd}"
 *   textFontStyle={{
 *     Font: '700 14/1.2 "Builder Sans"',
 *     LetterSpacing: -0.01,
 *     FontFamily: '"Builder Sans"',
 *     FontWeight: '700',
 *     FontSize: 14,
 *     LineHeight: 1.2
 *   }}
 *   textColor="white"
 *   textLink="www.example.com"
 *   openLinkInNewTab={true}
 * />
 */
const Text = ({ text, textFontStyle, textColor, textLink, openLinkInNewTab }) => {
    const { classes: { textElement } } = useStyles$5({
        textFontStyle,
        textColor
    });
    const { parsedTextContent } = useFormatText(text, textLink, openLinkInNewTab);
    return (React.createElement("span", { className: textElement, ...getTextDataAttribute(defaultTextDataAttributeConfig) }, parsedTextContent));
};

const DOM_PURIFY_CONFIG = {
    ALLOWED_TAGS: ['em', 'i', 'strong', 'b', 'u', 'a', 'br'],
    ALLOWED_ATTR: ['href', 'target', 'rel']
};
const useStyles$4 = makeStyles()((_theme, { textFontStyle, textColor }) => ({
    textElement: {
        ...textTruncationStylesWithWrap,
        ...getTextStyles(defaultTextDataAttributeConfig, textColor, textFontStyle)
    }
}));
/**
 * WebText component displays a block of text.
 *
 * @component
 * @param {string} text - The text to be displayed.
 * @param {TTypographyToken} textFontStyle - The font style of the text.
 * @param {string} textColor - The color of the text to be displayed.
 *
 * @example
 * <WebText
 *   text="Sample Text. Here is some nice text!<br />More text"
 *   textFontStyle={{
 *     Font: '700 14/1.2 "Builder Sans"',
 *     LetterSpacing: -0.01,
 *     FontFamily: '"Builder Sans"',
 *     FontWeight: '700',
 *     FontSize: 14,
 *     LineHeight: 1.2
 *   }}
 *   textColor="white"
 * />
 */
const WebText = ({ text, textFontStyle, textColor }) => {
    const { classes: { textElement } } = useStyles$4({
        textFontStyle,
        textColor
    });
    const sanitizedText = React.useMemo(() => domPurify.sanitize(text, DOM_PURIFY_CONFIG), [text]);
    return (React.createElement("span", { className: textElement, ...getTextDataAttribute(defaultTextDataAttributeConfig), 
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML: { __html: sanitizedText } }));
};

// convert color string to rgb and apply transparency
// transparency 1 = fully transparent, 0 = fully opaque
const getBackgroundColorWithTransparency = (color, transparency) => {
    try {
        const colorInstance = Color(color);
        const rgbArray = colorInstance.rgb().array();
        const [r, g, b] = rgbArray;
        return `rgba(${r}, ${g}, ${b}, ${1 - transparency})`;
    }
    catch {
        return color;
    }
};

const useStyles$3 = makeStyles()((_theme, { textColor, fontStyle, backgroundColor, backgroundTransparency, verticalPadding, horizontalPadding, containerOverrideStyles }) => ({
    pillText: {
        backgroundColor: 'transparent',
        padding: `${verticalPadding}px ${horizontalPadding}px`,
        ...getTextStyles(defaultTextDataAttributeConfig, textColor, fontStyle),
        ...textTruncationStyles
    },
    pillContainer: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        borderRadius: '999px',
        backgroundColor: getBackgroundColorWithTransparency(backgroundColor, backgroundTransparency),
        ...containerOverrideStyles
    }
}));
const TextPill = ({ text, textColor, fontStyle, backgroundColor, backgroundTransparency, verticalPadding, horizontalPadding, containerOverrides }) => {
    const containerOverrideStyles = useMemo(() => {
        if (containerOverrides) {
            return guiPropsToStyle(containerOverrides);
        }
        return {};
    }, [containerOverrides]);
    const { classes: { pillText, pillContainer } } = useStyles$3({
        textColor,
        fontStyle,
        backgroundColor,
        backgroundTransparency,
        verticalPadding,
        horizontalPadding,
        containerOverrideStyles
    });
    return (React.createElement("div", { className: pillContainer, "data-testid": 'pill-container' },
        React.createElement("span", { className: pillText, "data-testid": 'pill-text', ...getTextDataAttribute(defaultTextDataAttributeConfig) }, text)));
};

const useStyles$2 = makeStyles()((_theme, { titleHeight, titleLines, titleColor, titleFontStyles, isContained, containmentPadding }) => ({
    tileBottomContentContainer: {
        width: '100%',
        display: 'flex',
        flexDirection: 'row',
        gap: '4px',
        ...(isContained && {
            padding: `0px ${containmentPadding}px ${containmentPadding}px ${containmentPadding}px`
        })
    },
    tileBottomLeftContentContainer: {
        width: 'fit-content',
        maxWidth: '100%',
        overflow: 'hidden',
        // Allow the left content to grow and take up the remaining space
        flexGrow: 1,
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center'
    },
    tileBottomRightContentContainer: {
        width: 'fit-content',
        maxWidth: '100%',
        // Do not shrink the CTA button container
        flexShrink: 0,
        display: 'flex'
    },
    tileTitleContainer: {
        height: titleHeight
    },
    tileTitleText: {
        width: '100%',
        height: '100%',
        overflow: 'hidden',
        ...(titleLines === 1 && {
            ...textTruncationStyles
        }),
        ...getTextStyles(defaultTextDataAttributeConfig, titleColor, titleFontStyles)
    }
}));
/**
 * Renders the bottom content of a tile.
 *
 * Left side: title and footer
 * Right side: CTA button
 */
const TileBottomContent = ({ titleText, titleLines, titleFontStyles, titleColor, titleComponent, footerComponent, ctaButtonComponent, isContained, containmentPadding }) => {
    const titleHeight = titleLines * (titleFontStyles.LineHeight * titleFontStyles.FontSize);
    const { classes: { tileBottomContentContainer, tileBottomLeftContentContainer, tileBottomRightContentContainer, tileTitleContainer, tileTitleText } } = useStyles$2({
        titleHeight,
        titleLines,
        titleColor,
        titleFontStyles,
        isContained,
        containmentPadding
    });
    const titleContent = useMemo(() => {
        if (titleComponent) {
            return titleComponent;
        }
        if (titleText) {
            return (React.createElement("div", { className: tileTitleContainer, "data-testid": 'tile-title-container' },
                React.createElement("div", { className: tileTitleText, ...getTextDataAttribute(defaultTextDataAttributeConfig) }, titleText)));
        }
        return null;
    }, [titleComponent, titleText, tileTitleContainer, tileTitleText]);
    return (React.createElement("div", { className: tileBottomContentContainer },
        React.createElement("div", { className: tileBottomLeftContentContainer },
            titleContent,
            footerComponent && footerComponent),
        ctaButtonComponent && (React.createElement("div", { className: tileBottomRightContentContainer }, ctaButtonComponent))));
};

function useFocused() {
    const [isFocused, setIsFocused] = useState(false);
    const setFocusDebounced = debounce(() => {
        setIsFocused(true);
    }, 100);
    const onFocus = () => {
        setFocusDebounced();
    };
    const onFocusLost = () => {
        setFocusDebounced.cancel();
        setIsFocused(false);
    };
    return [isFocused, onFocus, onFocusLost];
}

const useStyles$1 = makeStyles()((_theme, { imageAspectRatio, isContained, containmentBackgroundColor, isFocused, cornerRadius, placeholderImageBackgroundColor }) => ({
    tileContainer: {
        width: '100%',
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        gap: '4px',
        ...(isContained && {
            borderBottomLeftRadius: `${cornerRadius}px`,
            borderBottomRightRadius: `${cornerRadius}px`,
            ...(containmentBackgroundColor && {
                backgroundColor: containmentBackgroundColor
            })
        })
    },
    tileImageContainer: {
        width: '100%',
        height: 'auto',
        aspectRatio: `${imageAspectRatio}`,
        position: 'relative',
        // On hover, add 10% white media overlay using a pseudo-element
        '&::before': {
            content: '""',
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            borderRadius: `${cornerRadius}px`,
            ...(isContained && {
                borderBottomLeftRadius: '0px',
                borderBottomRightRadius: '0px'
            }),
            backgroundColor: 'transparent',
            transition: `background-color ${transitionConfig.duration} ${transitionConfig.easing}`,
            ...(isFocused && {
                backgroundColor: 'rgba(255, 255, 255, 0.1)'
            })
        },
        '& img': {
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            aspectRatio: `${imageAspectRatio}`,
            borderRadius: `${cornerRadius}px`,
            ...(isContained && {
                borderBottomLeftRadius: '0px',
                borderBottomRightRadius: '0px'
            })
        }
    },
    placeholderImage: {
        width: '100%',
        height: '100%',
        aspectRatio: `${imageAspectRatio}`,
        backgroundColor: placeholderImageBackgroundColor,
        borderRadius: `${cornerRadius}px`,
        ...(isContained && {
            borderBottomLeftRadius: '0px',
            borderBottomRightRadius: '0px'
        })
    }
}));
const Tile = ({ isFocused, imageComponent, imageAspectRatio, thumbnailOverlayComponent, onActivated, linkPath, isContained, containmentPadding, containmentBackgroundColor, cornerRadius, titleText, titleColor, titleFont, titleLines, titleComponent, footerComponent, ctaButtonComponent, isOnScreen, placeholderImageBackgroundColor }) => {
    const [isTileFocused, onFocus, onFocusLost] = useFocused();
    // Derive hover state from either the props isFocused (from the parent element) or the Tile's own focus state
    const derivedIsFocused = isTileFocused || isFocused;
    const { classes: { tileContainer, tileImageContainer, placeholderImage } } = useStyles$1({
        imageAspectRatio,
        isContained,
        containmentBackgroundColor,
        isFocused: derivedIsFocused,
        cornerRadius,
        placeholderImageBackgroundColor
    });
    const derivedImageComponent = useMemo(() => {
        if (imageComponent) {
            return imageComponent;
        }
        return React.createElement("div", { "data-testid": 'placeholder-image', className: placeholderImage });
    }, [imageComponent, placeholderImage]);
    return (React.createElement(MaybeLinkActionWrapper, { containerClassName: tileContainer, callback: onActivated, linkPath: linkPath, tabIndex: isOnScreen ? 0 : -1, onFocus: onFocus, onFocusLost: onFocusLost, ariaLabel: titleText },
        React.createElement("div", { className: tileImageContainer },
            derivedImageComponent,
            thumbnailOverlayComponent),
        React.createElement(TileBottomContent, { titleText: titleText, titleLines: titleLines, titleColor: titleColor, titleFontStyles: titleFont, titleComponent: titleComponent, footerComponent: footerComponent, ctaButtonComponent: ctaButtonComponent, isContained: isContained, containmentPadding: containmentPadding ?? 0 })));
};

const useStyles = makeStyles()((_theme, { textHeight, textColor, textIconGap, sectionGap, fontStyle }) => ({
    tileFooterContainer: {
        display: 'flex',
        alignItems: 'center',
        gap: `${sectionGap}px`,
        width: '100%',
        height: textHeight,
        whiteSpace: 'nowrap',
        ...overrideDefaultButtonStyles
    },
    leftContainer: {
        flexShrink: 0,
        minWidth: 0,
        width: 'fit-content',
        maxWidth: '100%',
        display: 'flex',
        flexDirection: 'row',
        alignItems: 'center',
        gap: `${textIconGap}px`
    },
    rightContainer: {
        flexShrink: 1,
        minWidth: 0,
        display: 'flex',
        flexDirection: 'row',
        alignItems: 'center',
        gap: `${textIconGap}px`
    },
    textClassName: {
        width: '100%',
        height: '100%',
        ...textTruncationStyles,
        ...getTextStyles(defaultTextDataAttributeConfig, textColor, fontStyle)
    },
    iconContainer: {
        flexShrink: 0,
        display: 'flex',
        alignItems: 'center'
    }
}));
const TileFooter = ({ onActivated, linkPath, textColor, fontStyle, textIconGap, sectionGap, iconWidth, iconColor, leftIcon, leftIconComponent, leftText, rightIcon, rightIconComponent, rightText }) => {
    const textHeight = fontStyle.LineHeight * fontStyle.FontSize;
    // Default icon color and width to text color and height
    const derivedIconColor = iconColor ?? textColor;
    const derivedIconWidth = iconWidth ?? textHeight;
    const { classes: { tileFooterContainer, leftContainer, rightContainer, textClassName, iconContainer } } = useStyles({
        textHeight,
        textColor,
        textIconGap: textIconGap ?? 0,
        sectionGap: sectionGap ?? 0,
        fontStyle
    });
    const leftIconDisplay = useMemo(() => {
        if (leftIconComponent) {
            return leftIconComponent;
        }
        if (leftIcon) {
            return React.createElement(Icon, { iconClassName: leftIcon, color: derivedIconColor, width: derivedIconWidth });
        }
        return null;
    }, [leftIcon, leftIconComponent, derivedIconColor, derivedIconWidth]);
    const rightIconDisplay = useMemo(() => {
        if (rightIconComponent) {
            return rightIconComponent;
        }
        if (rightIcon) {
            return React.createElement(Icon, { iconClassName: rightIcon, color: derivedIconColor, width: derivedIconWidth });
        }
        return null;
    }, [rightIcon, rightIconComponent, derivedIconColor, derivedIconWidth]);
    const tileFooterContent = useMemo(() => (React.createElement(React.Fragment, null,
        React.createElement("div", { className: leftContainer },
            leftIconDisplay && (React.createElement("div", { className: iconContainer, "data-testid": 'left-icon-container' }, leftIconDisplay)),
            React.createElement("div", { className: textClassName, ...getTextDataAttribute(defaultTextDataAttributeConfig) }, leftText)),
        React.createElement("div", { className: rightContainer },
            rightIconDisplay && React.createElement("div", { className: iconContainer }, rightIconDisplay),
            rightText && (React.createElement("div", { className: textClassName, ...getTextDataAttribute(defaultTextDataAttributeConfig) }, rightText))))), [
        leftContainer,
        rightContainer,
        textClassName,
        leftIconDisplay,
        rightIconDisplay,
        leftText,
        rightText,
        iconContainer
    ]);
    return (React.createElement(MaybeLinkActionWrapper, { containerClassName: tileFooterContainer, callback: onActivated, linkPath: linkPath, ariaLabel: leftText }, tileFooterContent));
};

const useStyle$2 = makeStyles({ name: 'VerticalFeed' })((_theme, { maxWidth, gapBetweenFeedItems, paddingLeft, paddingRight }) => ({
    verticalFeedContainer: {
        display: 'flex',
        justifyContent: 'center',
        paddingLeft: paddingLeft ? `${paddingLeft}px` : '0px',
        paddingRight: paddingRight ? `${paddingRight}px` : '0px'
    },
    verticalFeedContentContainer: {
        display: 'flex',
        flexDirection: 'column',
        gap: `${gapBetweenFeedItems}px`,
        width: '100%',
        maxWidth: maxWidth ? `${maxWidth}px` : '100%'
    }
}));
const VerticalFeed = ({ feedItems, maxWidth, gapBetweenFeedItems = 0, paddingLeft, paddingRight }) => {
    const { classes } = useStyle$2({ maxWidth, gapBetweenFeedItems, paddingLeft, paddingRight });
    return (React.createElement("div", { className: classes.verticalFeedContainer },
        React.createElement("div", { className: classes.verticalFeedContentContainer }, feedItems.map(({ key, component }) => (React.createElement("div", { key: key }, component))))));
};

const useStyle$1 = makeStyles({ name: 'DetailsPageHeader' })((_theme, { backgroundMaxWidth, contentMaxWidth, contentPaddingLeft, contentPaddingRight }) => ({
    detailsPageHeaderContainer: {
        position: 'relative',
        display: 'flex',
        justifyContent: 'center'
    },
    backgroundContainer: {
        width: '100%',
        maxWidth: backgroundMaxWidth ? `${backgroundMaxWidth}px` : '100%'
    },
    contentContainer: {
        position: 'absolute',
        bottom: '24px',
        left: 0,
        width: '100%',
        paddingLeft: contentPaddingLeft ? `${contentPaddingLeft}px` : '0px',
        paddingRight: contentPaddingRight ? `${contentPaddingRight}px` : '0px',
        display: 'flex',
        justifyContent: 'center'
    },
    contentMaxWidthContainer: {
        width: '100%',
        maxWidth: contentMaxWidth ? `${contentMaxWidth}px` : '100%'
    }
}));
const DetailsPageHeader = ({ backgroundComponent, backgroundMaxWidth, contentComponent, contentMaxWidth, contentPaddingLeft, contentPaddingRight }) => {
    const { classes } = useStyle$1({
        backgroundMaxWidth,
        contentMaxWidth,
        contentPaddingLeft,
        contentPaddingRight
    });
    return (React.createElement("div", { className: classes.detailsPageHeaderContainer },
        React.createElement("div", { className: classes.backgroundContainer }, backgroundComponent),
        React.createElement("div", { className: classes.contentContainer },
            React.createElement("div", { className: classes.contentMaxWidthContainer }, contentComponent))));
};

const useStyle = makeStyles({ name: 'Page' })((_theme, { backgroundColor }) => ({
    pageContainer: {
        display: 'flex',
        flexDirection: 'column',
        minHeight: '100vh',
        gap: '24px',
        ...(backgroundColor && {
            backgroundColor
        })
    }
}));
const Page = ({ backgroundColor, pageHeader, feed }) => {
    const { classes } = useStyle({ backgroundColor });
    return (React.createElement("div", { className: classes.pageContainer },
        pageHeader,
        feed));
};

export { AssociatedItemsRow, AttributionRow, AttributionTextContent, CollectionCarousel, CollectionGrid, CollectionItemSize, CountdownTextIconRow, CtaButton, DetailsPageHeader, GameTileActiveFriendsFacepile, Gradient, HeroUnit, HeroUnitBottomRow, ImageWithGradient, MaybeLinkActionWrapper, OverlayPill, Page, SectionHeader, SlotOverlay, TAutomaticSize, Text, TextIconRow, TextPill, Tile, TileFooter, VerticalFeed, WebText, useElementWidthResizeObserver };
